::::::::::::::
check.f
::::::::::::::
      subroutine chk_input
c     ============================================================
c     check for inconsistencies of correlated input parameter
c     such as magin and maginfile. guerantee compability for 
c     older versions of genesis 1.3
c     ------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'sim.cmn'
      include 'mpi.cmn'
      include 'field.cmn'
c
      integer i,ix
      real*8  rw0
c
c     set seeds for random number generator to negative value    
c
      iseed=-iabs(iseed)
      ipseed=-iabs(ipseed)
      quadf=abs(quadf)
      quadd=-abs(quadd)
c
c     save the input value for gamma0 for diagnostic output and advanced scan
c
      gamma0_in=gamma0
c
c     set flags to either 0 or 1 + adjust values 
c
      if (isravg.ne.0) isravg=1
      if (isrsig.ne.0) isrsig=1
      if (lbc.ne.0) lbc=1
      if (iorb.ne.0) iorb=1
      if (magin.ne.0) magin=1
      inorun=0							! do not stop after initialization 
      if (magout.lt.0) inorun=1 		! enforce termination after initialization
      if (magout.ne.0) magout=1
      if (idump.ne.0) idump=1
      if (idmppar.ne.0) idmppar=1
      if (idmpfld.ne.0) idmpfld=1
      if (iotail.ne.0) iotail=1
      if (ilog.ne.0) ilog=1
      if (iall.ne.0) iall=1
      if (itdp.ne.0) itdp=1
      if (wcoefz(2).gt.1) wcoefz(2)=1.d0
      if (iwityp.ne.0) iwityp=1
      if (delaw.lt.small) iertyp=0
      if (iertyp.eq.0) delaw=0.d0
      if (ffspec.ne.0) ffspec=ffspec/abs(ffspec)
      if (isntyp.ne.0) isntyp=1             
      if ((dgrid.le.small).and.(zrayl.gt.0.)) then  !grid size determined by beam size?
         rw0 = dsqrt((zrayl*xlamds/pi)*(1.0d0+(zwaist/zrayl)**2))
         dgrid = rmax0*(rw0+dsqrt(rxbeam**2+rybeam**2))/2.d0
      endif   
c
c     check for ione4one
c
      if (ione4one.ne.0) then
        nbins=1
        ione4one=1
      endif
      
c
c     define harmonic content
c
      nhloop=1
      hloop(1)=1
      if (nharm.gt.1) then             ! changed to avoid nharm=0 settings
        if(iallharm.ne.0) then	         ! denotes which harmonics shall be calculated
          nhloop=nharm
	  do i=2,nharm			 !fill array with harmonic numbers
             hloop(i)=i
          end do			
        else
          nhloop=2                      ! else only fundamental + one harmonic
	  hloop(2)=nharm
	endif
      else
        pradh0=0.
      endif
c
c     check for version specific changes
c
      if (idmppar.eq.0) idmppar=idump
c
      if (version.lt.1.0) then
         ffspec=0			!phase in near field
         isntyp=1			!shotnoise with Penman algorithm
         inorun=0
      else  
         if (idmpfld.eq.0) idmpfld=idump
      endif            
c
c     check case if time dependent code is selected
c
      if (itdp.eq.0) then
        nslice=1                             !one slice 
        zsep=1                               !one bucket
        ntail=0                              !middle of the beam
        curlen=-1.d0                         !step profile in z
        shotnoise=0.d0                       !no phase fluctuation 
        iall=1                               !reference loading for scan
        ishsty=1                             !make sure for output
        isradi=1                             ! -- " --
        ispart=1                             ! -- " --
        iotail=0                             !cut tails
      endif
c
c     check for scan function 
c
      if (index(scan,' ').ne.1) iscan=chk_scan(scan,iscan)
c
      if (iscan.gt.0) then
        if (nscan.le.1) then
           i=printerr(errinwarn,'NSCAN too small for scan') 
           iscan=0
        else   
          if (((magin+magout).gt.0).and.((iscan.eq.5).or.(iscan.eq.6)
     c         .or.(iscan.eq.13).or.(iscan.eq.14))) then
            if (magin.ne.0) then
               i=printerr(errscanm1,maginfile) 
               iscan=0
            else
               i=printerr(errscanm2,magoutfile)
               iscan=0
            endif   
          else
            nslice=nscan
            iall=1
            zsep=delz
            curlen=-1.d0
            ntail=0
            iotail=0
            shotnoise=0.0
            if (itdp.ne.0) then
              i=printerr(errscant,' ')
              itdp=0
            endif
            if ((iscan.gt.22).and.(index(beamfile,' ').eq.0)) then
              i=printerr(errinput,'scan feature requires BEAMFILE')
              call last
            endif
          endif  
        endif  
      endif
c
c     check for magnet field input & output 
c
      if (index(maginfile,' ').ne.1) then
         magin=1
      else   
        if (magin.ne.0) then
          if (ilog.ne.0) then     
            i=printerr(errrequest,'MAGINFILE')   !interaction required
            call last
          endif
 1        write(6,100) 
          read(5,200) maginfile !get magnetic input file name
          if (index(maginfile,' ').eq.1) then
             i=printerr(errinvalname,maginfile)
             goto 1
          endif   
        endif
      endif 
      if (index(magoutfile,' ').ne.1) then
         magout=1
      else   
        if (magout.ne.0) then
           if (ilog.ne.0) then     
             i=printerr(errrequest,'MAGOUTFILE')   !interaction required
             call last
           endif
 2         write(6,110)
           read(5,200) magoutfile !get magnetic input file name
           if (index(magoutfile,' ').eq.1) then
              i=printerr(errinvalname,magoutfile)
              goto 2
           endif   
        endif
      endif 
c
c     check for output parameters
c
      if (ishsty.lt.1) ishsty=1
      if (ispart.lt.1) ispart=1
      if (isradi.lt.1) isradi=1
      ix=0
      do i=1,16+4*(nhmax-1)
         if (lout(i).ne.0) then
            ix=ix+1
            lout(i)=1
         endif   
      enddo
      if (ix.eq.0) iphsty=0
      return
c
c     format statements
c
 100  format('Please enter magnetic input file name')
 110  format('Please enter magnetic output file name')
 200  format(a30)
c 
      end !chk_input

      function chk_bnd()
c     ==================================================================
c     checks some boundaries of the input file.
c     ------------------------------------------------------------------
c
      include  'genesis.def'
      include  'input.cmn'
      include  'time.cmn'
      include  'io.cmn'
c
      integer itmp,ibas(7),i1,i2,i
c
c
c     check for the case that convharm is set if no partfile is defined 
c
      if (npin.le.0) convharm=1
c
      chk_bnd=noerr
      itmp=0     
c
c     case if nslice is smaller than 1  (auto-adjustment)  
c
      if (nslice.le.0) then
        if (curlen.lt.0) then      ! step profile
          ntail=0
          nslice=int(abs(curlen)/xlamds/zsep)
        else                       ! gaussian
          ntail=-int(3.d0*curlen/xlamds/zsep)
          nslice=int(6.d0*curlen/xlamds/zsep)
        endif
      endif 
c
c     adjustment for nslice if beamfile determines the scan
c
      if (iscan.gt.22) then
         if (ndata.le.0) then
            i=printerr(errinput,'BEAMFILE for scan not defined')
            call last
         endif
         nslice=ndata
         nscan=ndata
      endif

      if ((aw0.le.0.d0).and.(magin.eq.0)) then
         itmp=printerr(errinput,'No resonable wiggler field defined') !abort
      endif
      if (nwig.le.0) then
         itmp=printerr(errinput,'NWIG must be positive and non-zero')
      endif
      if (delz.le.0) then
         itmp=printerr(errinput,'DELZ must be positive and non-zero')
      endif
      if ((zsep.lt.1).and.(itdp.eq.1)) then
         itmp=printerr(errinput,'ZSEP must be al least 1')
      endif
      if (xlamd.le.0) then
         itmp=printerr(errinput,'XLAMD must be positive and non-zero')  !abort
      endif        
      if ((gamma0-4*abs(delgam)).lt.1) then
         itmp=printerr(errinput,'energy GAMMA0 too small')  !abort
      endif
      if(npart.gt.npmax) then
         i=printerr(errinwarn,'NPART > NPMAX - setting NPART=NPMAX')
      endif
      if ((nbins.lt.4).and.(ione4one.eq.0)) then
        i=printerr(errinwarn,'NBINS too small - setting NBINS=4')
        nbins=4
      endif  
c      
c     changed for ione4one simulation. nbins just need to be a factor of npart
c
      if(mod(npart,nbins).ne.0) then
         itmp=printerr(errinput,'NPART not a multiple of NBINS') !abort
      endif

      if (lout(15+nharm).eq.0) then
          i=printerr(errinwarn,'LOUT for NHARM not selected')
      endif

      do i1=nharm+1,nhmax
        if (lout(15+i1).ne.0) then
            i=printerr(errinwarn,'LOUT above NHARM selected')
        endif
      enddo 

      do i1=2,nharm-1
         if (lout(15+i1).ne.iallharm) then
           if (iallharm.eq.0) then
             i=printerr(errinwarn,'LOUT below NHARM selected')
            else
             i=printerr(errinwarn,'LOUT below NHARM not selected')
           endif
         endif
      enddo 
       

 
      if (idmppar.gt.nharm) then
          i=printerr(errinwarn,'No dump possible (IDMPPAR > IHARM)')
          idmppar=0
      endif    
      if (xlamds.le.0) then
         itmp=printerr(errinput,'XLAMDS must be positive')  !abort
      endif        
      if (prad0.lt.0.d0) then
         itmp=printerr(errinput,'PRAD0 must not be negative')!abort
      endif
      if (pradh0.lt.0.d0) then
         itmp=printerr(errinput,'PRADH0 must not be negative')!abort
      endif
      ibas(1)=ildpsi
      ibas(2)=ildx
      ibas(3)=ildy
      ibas(4)=ildpx
      ibas(5)=ildpy
      ibas(6)=ildgam
      ibas(7)=ildgam+1
      do i1=1,7
       do i2=i1+1,7
        if (ibas(i1).eq.ibas(i2)) then !no abort
         i=printerr(errinwarn,'Identical bases in Hammersley sequences')
        endif
       enddo
      enddo   
      if ((abs(iertyp).ne.0).and.(abs(delz-0.5d0).gt.small)) then
         itmp=printerr(errinput,'DELZ must be 0.5 for field errors')
      endif
      if (iscan.gt.25) then
        i=printerr(errinwarn,'Invalid scan parameter - setting ISCAN=0')
        iscan=0
      endif
      if ((iscan.gt.0).and.((nscan.le.1).or.(abs(svar).lt.small))) then
         itmp=printerr(errinput,'Invalid scan range (NSCAN,SVAL)')
      endif
      if ((zsep/delz-1.*int(zsep/delz)).gt.small) then
         itmp=printerr(errinput,'ZSEP not a multiple of DELZ')
      endif 
      if (nslice.gt.nsmax) then
         itmp=printerr(errinput,'Too many slices (NSLICE>NSMAX)')
      endif
      if (nslice.le.0) then
         itmp=printerr(errinput,'NSLICE < 1')
      endif
      if (zrayl.le.0.) then
         itmp=printerr(errinput,'ZRAYL must be larger than 0')
      endif
      if(mod(ncar,2).eq.0) then
         itmp=printerr(errinput,'NCAR not an odd integer') 
      endif                
      if(ncar.gt.ncmax) then
         i=printerr(errinwarn,'NCAR too large - setting NCAR=NCMAX')
      endif                
      if (nptr.gt.nrgrid-1) then
         i=printerr(errinwarn,'NPTR too large - setting NPTR=NRGRID')
      endif
      if (nptr.lt.2) then
        i=printerr(errinwarn,'NPTR too small - disabling space charge')
        nscz=0
        nscr=0
      endif
      if ((nscz.ge.(nbins/2+1)).and.(ione4one.eq.0)) then  !somehow empirical boundary
        i=printerr(errinwarn,'NSCZ too large - setting NSCZ=2')
        nscz=2
      endif        
      if ((nharm.gt.(nbins/2+1)).and.(ione4one.eq.0)) then
        i=printerr(errinwarn,'Higher harmonics are inaccurate (NHARM)')
      endif
c
      chk_bnd=itmp
      return
      end     !chk_bnd
c
      function chk_scan(c0,iscn)
c     ============================================================
c     check for string in input scan
c     ------------------------------------------------------------
c
      character*30 c0
      integer i,j,iscn,chk_scan 
c
      chk_scan=iscn          !if not found use value if iscan
      call touppercase(c0)
      j=1
      do i=1,30               !conversion to uppercase 
         if (c0(i:i).gt.' ') j=i    !end of string?
      enddo

      if (c0(1:j).eq.'GAMMA0')  chk_scan=1
      if (c0(1:j).eq.'DELGAM')  chk_scan=2
      if (c0(1:j).eq.'CURPEAK') chk_scan=3
      if (c0(1:j).eq.'XLAMDS')  chk_scan=4
      if (c0(1:j).eq.'AW0')     chk_scan=5
      if (c0(1:j).eq.'ISEED')   chk_scan=6
      if (c0(1:j).eq.'PXBEAM')  chk_scan=7
      if (c0(1:j).eq.'PYBEAM')  chk_scan=8
      if (c0(1:j).eq.'RXBEAM')  chk_scan=11
      if (c0(1:j).eq.'RYBEAM')  chk_scan=12
      if (c0(1:j).eq.'XBEAM')   chk_scan=9
      if (c0(1:j).eq.'YBEAM')   chk_scan=10
      if (c0(1:j).eq.'XLAMD')   chk_scan=13
      if (c0(1:j).eq.'DELAW')   chk_scan=14
      if (c0(1:j).eq.'ALPHAX')  chk_scan=15
      if (c0(1:j).eq.'ALPHAY')  chk_scan=16
      if (c0(1:j).eq.'EMITX')   chk_scan=17
      if (c0(1:j).eq.'EMITY')   chk_scan=18
      if (c0(1:j).eq.'PRAD0')   chk_scan=19
      if (c0(1:j).eq.'ZRAYL')   chk_scan=20
      if (c0(1:j).eq.'ZWAIST')  chk_scan=21
      if (c0(1:j).eq.'AWD')     chk_scan=22
      if (c0(1:j).eq.'BEAMFILE')chk_scan=23
      if (c0(1:j).eq.'BEAMOPT') chk_scan=24
      if (c0(1:j).eq.'BEAMGAM') chk_scan=25

      
      return
      end
::::::::::::::
diagno.f
::::::::::::::
      subroutine diagno(istepz)
c     ==================================================================
c     some diagnostics:
c     the radiation power must be calculated for each integration step
c     otherwise error will be wrong.
c     all calculation are stored in a history arrays which will be
c     written to a file ad the end of the run.
c     ------------------------------------------------------------------
c
      include  'genesis.def'
      include  'sim.cmn'
      include  'input.cmn'
      include  'field.cmn'
      include  'particle.cmn'
      include  'diagnostic.cmn'
      include  'work.cmn'
      include  'magnet.cmn'    ! unofficial
c
      integer i,ip,ix,iy,i0,i1,nn(2),istepz,nctmp,n
      integer ioff
      real*8 xavg,yavg,tpsin,tpcos,prad,ptot,gainavg,
     +       xxsum,yysum,cr2,crsum,wwcr,pradn 
      complex*16 ctmp 
c
      if (iphsty.le.0) return      !no output at all
      if (mod(istepz,iphsty).ne.0) return  ! no evaluation at this step
      if (istepz.eq.0) then 
          ihist=1                 ! first initialization of step counter
      else 
          ihist=ihist+1           ! advancing step counter for history counter
      endif
c
c     diagnostic: radiation field
c     -----------------------------------------------------------------
c     
c     radiation power
c
      do n=1, nhloop   ! looping over harmonics
        crsum=0.0d0
        ctmp=dcmplx(0.,0.)
        ioff=(n-1)*ncar*ncar
        do i=1+ioff,ncar*ncar+ioff
          wwcr=dble(crfield(i)*conjg(crfield(i))) !=sum of |aij|^2 
          crsum=crsum+wwcr
          ctmp=ctmp+crfield(i)
        end do
        pradn=crsum*(dxy*eev*xkper0/xks/hloop(n))**2/vacimp  != current radiation power
        if (n.eq.1) then    
          if ((pradoln(n).gt.0.d0).and.(pradn.gt.0.d0)) then
            logp(ihist)=dlog(pradn/pradoln(n))/(delz*xlamd) ! log derivative for fundamental harmonics
          else
            logp(ihist)=0.
          endif 
        endif
        gainavg=0.5d0*(pradn+pradoln(n))            !average with old power (leap frog!)
        pgainhist(hloop(n),ihist)=pradn
        pradoln(n)=pradn                            !store actual value as old value
c
c       on-axis far field intensity
c     
        ctmp=ctmp*eev*xkper0**2/xks/hloop(n)/sqrt(vacimp)   !scale it to dw/domega
        ffield(hloop(n),ihist)=dble(ctmp*conjg(ctmp)) ! far field on-axis (a.u.)   
c
c       on-axis near field intensity
c 
        i=ncar*(ncar-1)/2+(ncar+1)/2+(n-1)*ncar*ncar
      
        pmidhist(hloop(n),ihist)=dble(crfield(i)*conjg(crfield(i)))		!kg
     +       *(dxy*eev*xkper0/xks/hloop(n))**2/vacimp

        if (abs(crfield(i)).gt.0) then	
          phimid(hloop(n),ihist)=datan2(dimag(crfield(i)),
     +                  dble(crfield(i)))	
        else
          phimid(hloop(n),ihist)=0
        endif
        if (ffspec.lt.0) then
           if (abs(ctmp).gt.0) then
  	     phimid(hloop(n),ihist)=datan2(dimag(ctmp),dble(ctmp))
           else
             phimid(hloop(n),ihist)=0
           endif
	   pmidhist(hloop(n),ihist)=ffield(hloop(n),ihist)                  		
	 
        endif
        if (ffspec.gt.0) then
	  pmidhist(hloop(n),ihist)=pgainhist(hloop(n),ihist)		!kg		
        endif
      enddo   !end of loop over harmonics
c         
c     radiation size  of fundamental
c
      if (pradoln(1).gt.0.d0) then
        crsum=0.
        xavg=0.0d0
        yavg=0.0d0
        cr2=0.0d0
        do iy=1,ncar
          do ix=1,ncar
            i=(iy-1)*ncar+ix
            wwcr=dble(crfield(i)*conjg(crfield(i)))
            crsum=crsum+wwcr
            xavg=xavg+wwcr*dble(ix)                      !sum up position
            yavg=yavg+wwcr*dble(iy)
            cr2=cr2+wwcr*dble(ix*ix+iy*iy)
          end do
        end do
        xavg=xavg/crsum                                !center of radiation
        yavg=yavg/crsum
        cr2=cr2/crsum-xavg*xavg-yavg*yavg
      else 
        cr2=0.d0
      endif
      whalf(ihist)=dsqrt(cr2)*dxy/xkper0     !rms radiation size

c
c     diagnostic: electron beam
c     ------------------------------------------------------------------
c
c     energy
c
      gamhist(ihist) =0.
      dgamhist(ihist)=0.
      do ip=1,npart
         gamhist(ihist) =gamhist(ihist)+(gamma(ip)-gamma0_in) 
         dgamhist(ihist)=dgamhist(ihist)+(gamma(ip)-gamma0_in)**2 
      enddo
      if (npart.gt.0) then
        gamhist(ihist)=gamhist(ihist)/dble(npart)
        dgamhist(ihist)=
     c      sqrt(dgamhist(ihist)/dble(npart)-gamhist(ihist)**2)
c
      endif
      ptot=pradoln(1)+eev * xcuren * gamhist(ihist)   !1st part of total energy      
      if (istepz.eq.0) pinit=ptot

c
c     bunching at nharm harmonics
c
      do i=1,nhloop
        tpsin=0.0d0                              
        tpcos=0.0d0
        do ip=1,npart
          tpsin=tpsin+dsin(theta(ip)*dble(i))          !add up phases
          tpcos=tpcos+dcos(theta(ip)*dble(i))
        end do   !ip
        if (npart.gt.0) then
          tpsin=tpsin/dble(npart)     
          tpcos=tpcos/dble(npart)
         endif
        pmodhist(i,ihist)=dsqrt(tpsin**2+tpcos**2) !bunching factor
        if (pmodhist(i,ihist).gt.0) then
           bunphase(i,ihist)=datan2(tpsin,tpcos)      !bunching phase
        else
           bunphase(i,ihist)=0
        endif
      enddo
      do i=nhloop+1,nhmax
        pmodhist(i,ihist)=0.
        bunphase(i,ihist)=0.
      enddo 
c
c     beam radius & energy spread
c
      xxsum=0.0d0    !reset counter
      yysum=0.0d0
      xpos(ihist)=0.0d0   
      ypos(ihist)=0.0d0
c     
      do i=1,npart
         xxsum=xxsum+xpart(i)**2     !sum of radii squared
         yysum=yysum+ypart(i)**2
         xpos(ihist)=xpos(ihist)+xpart(i)          !sum of radii 
         ypos(ihist)=ypos(ihist)+ypart(i)
      end do       ! i
      if (npart.gt.0) then
        xpos(ihist)=xpos(ihist)/dble(npart)/xkper0     !mean value
        ypos(ihist)=ypos(ihist)/dble(npart)/xkper0     
        xxsum=xxsum/dble(npart)/xkper0/xkper0    !mean square value
        yysum=yysum/dble(npart)/xkper0/xkper0    
      endif  
      xrms(ihist)=dsqrt(xxsum-xpos(ihist)**2)
      yrms(ihist)=dsqrt(yysum-ypos(ihist)**2)
c
c     energy conservation
c     ----------------------------------------------------------------
c
      error(ihist)=0.
      if (gainavg.ne.0.0) then
        error(ihist)=100.d0*(ptot/gainavg-pinit/gainavg)
      endif   
c
      if (lout(6).eq.0) return
c 
c     diffraction angle of radiation field
c     ---------------------------------------------------------------
c
      if (pradoln(1).eq.0) then   ! no radiation field
         diver(ihist)=0.
         return
      endif 
c
      nctmp=2**(int(log(float(ncar))/log(2.))+1)   !with nctmp> ncar
      do i1=1,nctmp*nctmp
         crwork3(i1)=(0.d0,0.d0)                   !clear working
      enddo
      i=(nctmp-ncar)/2                             !first index in bigger mesh
      do ix=1,ncar
         do iy=1,ncar
            i0=(ix-1)*ncar+iy
            i1=(ix-1+i)*nctmp+iy+i
            crwork3(i1)=crfield(i0)                !copy field around mid point 
         enddo
      enddo
      nn(1)=nctmp                                  !size of mesh
      nn(2)=nctmp
c
c     debug
c
c      crsum=0.0
c      do i=1,ncar*ncar
c         =crsum+dble(crwork3(i)*conjg(crwork3(i)))
c      enddo
c      write (*,*) 'field power before fft',crsum

      call fourn(crwork3,nn,2,1)                   !2d fft with complex variables 
c
c     debug
c
c      crsum=0.0
c      do i=1,ncar*ncar
c         crsum=crsum+dble(crwork3(i)*conjg(crwork3(i)))
c      enddo
c      write (*,*) 'field power before fft',crsum

c      pause
c
      do ix=1,nctmp/2                              !rearrange fft output
         do iy=1,nctmp/2
            i0=(ix-1)*nctmp+iy
            i1=(ix-1+nctmp/2)*nctmp+iy+nctmp/2
            ctmp=crwork3(i1) 
            crwork3(i1)=crwork3(i0) 
            crwork3(i0)=ctmp
            i0=(ix-1)*nctmp+iy+nctmp/2
            i1=(ix+nctmp/2-1)*nctmp+iy 
            ctmp=crwork3(i1) 
            crwork3(i1)=crwork3(i0) 
            crwork3(i0)=ctmp
         enddo
      enddo
c
      xavg=0.0d0
      yavg=0.0d0
      crsum=0.0d0
      do iy=1,nctmp
        do ix=1,nctmp
          i=(iy-1)*nctmp+ix
          wwcr=dble(crwork3(i)*conjg(crwork3(i)))
          xavg=xavg+wwcr*dble(ix)                      !sum up spatial frequency
          yavg=yavg+wwcr*dble(iy)
          crsum=crsum+wwcr
        end do
      end do
      if (crsum.gt.0.0) then
        xavg=xavg/crsum                                  !center of spatial frequency
        yavg=yavg/crsum
      else
        xavg=0.
        yavg=0.
      endif
c
      cr2=0.0d0
      do iy=1,nctmp
         do ix=1,nctmp
            i=(iy-1)*nctmp+ix
            wwcr=dble(crwork3(i)*conjg(crwork3(i)))
            cr2=cr2+wwcr*((dble(ix)-xavg)**2+(dble(iy)-yavg)**2)
         end do
      end do
c      
      if (crsum.le.0.0) then
         cr2=0.
         crsum=1.
      endif
c
      diver(ihist)=dsqrt(cr2/crsum)*xkper0*xlamds/dxy/dble(nctmp)  !rms divergence angle
c
      return
      end


::::::::::::::
esource.f
::::::::::::::
      subroutine esource(istepz,thet)
c     ==================================================================
c     calculates the space charge field.
c     all particle are discretized on a radial mesh for all
c     selected azimutal and longitudinal fourier modes.
c     ------------------------------------------------------------------
c
      include  'genesis.def'
      include  'input.cmn'
      include  'particle.cmn'
      include  'work.cmn'
c
      integer m,j,ip,ir,istepz
c
      complex *16 vn,coef,cma(nrgrid),cmb(nrgrid),cmc(nrgrid),
     +            crtmp1(nrgrid),crtmp2(nrgrid),cscsource(nrgrid),
     +            ctemp
      real*8 econst,rscmax,drsc,vol(nrgrid),xmid,ymid,xks,xkw0,
     +       rmid(nrgrid),rlog(nrgrid),rdig(nrgrid)      
      real*8 ezmax 
      real*8 thet
      dimension thet(*)
c
      if (nscz.le.0) return                       !no space charge selected
c

      xks=twopi/xlamds
      xkw0=twopi/xlamd

      xmid=0.0d0              !get centroid position   
      ymid=0.0d0
      do ip=1,npart
         xmid=xmid+xpart(ip)       
         ymid=ymid+ypart(ip)
      end do       ! i
      if (npart.gt.0) then
        xmid=xmid/dble(npart)   !mean value
        ymid=ymid/dble(npart)     
      endif
c      
      do ip=1,npart 
        ez(ip)=0.d0                               !clear old space charge field
        p1(ip)=(xpart(ip)-xmid)*(xpart(ip)-xmid)
        p1(ip)=p1(ip)+(ypart(ip)-ymid)*(ypart(ip)-ymid)
        p1(ip)=dsqrt(p1(ip))/xkw0
      enddo
c
c     grid size
c
      if (rmax0sc.gt.0) then
       rscmax=rmax0sc                           ! domainsize defined explicitly in input deck
      else  
       rscmax=p1(1)     
       do ip=2,npart
          if (p1(ip).gt.rscmax) rscmax=p1(ip)       !look for maximum radius  
       enddo
       rscmax=rscmax+5*gamma0/xks                ! add extra space for fringe field
      endif
c
c     initial set-up for the grid
c
      drsc=rscmax/float(nptr-1) 
      do ir=2,nptr
        vol(ir)=pi*drsc*drsc*(2.*ir-1)            !2d volume around grid point
        rlog(ir)=log(float(ir)/float(ir-1))       !log term of higher modes
        rdig(ir)=2.*pi*float(ir-1)                !diagonal terms above/below main diag. 
      end do
      vol(1)=pi*drsc*drsc                         !volume of origin            
      rlog(1)=log(0.5)                            !shielding radius
      rdig(1)=0.                                  !no lower element at origin
      rdig(nptr+1)=0.                             !no upper element at border 
c
      econst=vacimp/eev*xcuren/float(npart)/(xks+xkw0)  !source term normalization
      coef=dcmplx(1.d0/(xks**2-(xks+xkw0)**2),0.d0) !matrix normalisation 
c
c     get position on the grid
c
      do ip=1,npart
        iwork(ip)=int((p1(ip))/drsc)+1
        if (iwork(ip).lt.1) iwork(ip)=1
        if (iwork(ip).ge.nptr) iwork(ip)=nptr-1   
        p2(ip)=1-((iwork(ip))*drsc-p1(ip))/drsc             ! get weighting for grid index iwork(ip)  
        p2(ip)=1.

      enddo
c
c     get azimuthal angle if needed
c
      if (nscr.gt.0) then
        do ip=1,npart 
          p1(ip)=datan2(ypart(ip)-ymid,xpart(ip)-xmid)
        end do
      endif
c
c     loop over azimuthal and longitudinal modes
c
      do m=-nscr,nscr
c
        do ir=1,nptr
          rmid(ir)=-rdig(ir)-rdig(ir+1)-2.*pi*dble(m*m)*rlog(ir)             !main diagonal elements 
        end do
        rmid(nptr)=rmid(nptr)-2.*pi*float(nptr)     !direchlet boundary condition
c         
        if (m.eq.0) then
          do ip=1,npart
            cpart2(ip)=dcmplx(1.0,0.)
          end do
        else
          do ip=1,npart
            cpart2(ip)=dcmplx(dsin(m*p1(ip)),-dcos(m*p1(ip)))
          end do
        endif
c
        do j=1,nscz
          do ir=1,nptr
            cscsource(ir)=dcmplx(0.d0,0.d0)      !clear source  
          end do
          do ip=1,npart
            ir=iwork(ip)
            ctemp=cpart2(ip)*dcmplx(dcos(j*thet(ip)),-dsin(j*thet(ip)))
            cscsource(ir)=cscsource(ir)+p2(ip)*ctemp
            cscsource(ir+1)=cscsource(ir+1)+(1-p2(ip))*ctemp
          end do 
          do ir=1,nptr 
             vn=dcmplx(0.d0,econst/float(j)/vol(ir)) !complex norm. term
             cscsource(ir)=vn*cscsource(ir)            !scale source term (current density)
             cma(ir)=coef*dcmplx(rdig(ir)/j/j/vol(ir),0.d0)  !construct complex matrix
             cmb(ir)=(1.d0,0.d0)+coef*dcmplx(rmid(ir)/j/j/vol(ir),0.d0)
             cmc(ir)=coef*dcmplx(rdig(ir+1)/j/j/vol(ir),0.d0)
          end do 
c            
          call trirad(cma,cmb,cmc,cscsource,crtmp1,crtmp2,nptr) !solve equation
c
c       for debug purposes
c
c          if ((m.eq.0).and.(j.eq.1).and.(istepz.gt.0)) then
c             write(69,rec=2*istepz-1) (cscsource(ir),ir=1,nptr)
c             write(69,rec=2*istepz) (crtmp1(ir),ir=1,nptr)
c          endif
c
c
          do ip=1,npart                         !sum up fourier coefficient
             ir=iwork(ip)
             ctemp=dcmplx(dcos(j*thet(ip)),dsin(j*thet(ip)))
             ctemp=ctemp*conjg(cpart2(ip))
             ez(ip)=ez(ip)+2.*p2(ip)*dble(crtmp1(ir)*ctemp)
     +             +2.*(1-p2(ip))*dble(crtmp1(ir+1)*ctemp)
          end do
        end do
      enddo
c
      do ip=1,npart
         ez(ip)=ez(ip)/xkw0           !scale due to normalized z
      enddo

      return
      
      end 




      subroutine trirad(a,b,c,r,u,w,n)
c     ==================================================================
c     solve a tridiagonal system for radial mesh
c     only called by esource for space charge calculation
c     ------------------------------------------------------------------
c
      integer n,k
      complex*16 w(*),a(*),b(*),c(*),r(*),u(*),bet
c

      bet=b(1)
      u(1)=r(1)/bet
      do k=2,n
	 w(k)=c(k-1)/bet
	 bet=b(k)-a(k)*w(k)
	 u(k)=(r(k)-a(k)*u(k-1))/bet
      end do       ! k
      do k=n-1,1,-1
	 u(k)=u(k)-w(k+1)*u(k+1)
      end do       ! k
c
      return
      end     !trirad
::::::::::::::
field.f
::::::::::::::
      subroutine field(ihloop)
c     ==================================================================
c     integrate the wave equation one step in z for cartesian mesh
c     using adi - methode (alternationg direction implicit)
c        1: u(n+1/2)=u(n)+alpha/2(dx u(n+1/2)+dy u(n))
c        2: u(n+1)=u(n+1/2)+alpha/2(dx u(n+1/2)+dy u(n+1))  
c        to use tridiag methode transpose data array:
c        (1)->u(n)->u(i,j)->u(j,i)->u(n)->(2)->transpose again 
c     ------------------------------------------------------------------
c
      include   'genesis.def'
      include   'field.cmn'
      include   'input.cmn'
c
      integer ioff
      integer ix,idx,i,ihloop,n
c
      ioff=(ihloop-1)*ncar*ncar   ! note that ihloop is the harmonic counter but not the harmonics!
c
c     homogenious part to right hand side of diff equation (1)
c     ------------------------------------------------------------------
c      
        do ix=1,ncar
          crhm(ix)=crsource(ix)+crfield(ix+ioff)
     +           +cstep(ihloop)*(crfield(ix+ioff+ncar)   ! boundary :field = 0 for ix-ncar
     +           -crfield(ix+ioff)*2.)        
        end do
        do idx=ncar+1,ncar*(ncar-1)
            crhm(idx)=crsource(idx)+crfield(idx+ioff)
     +              +cstep(ihloop)*(crfield(idx+ncar+ioff)
     +              +crfield(idx-ncar+ioff)-2.*crfield(idx+ioff))
        end do
        do idx=ncar*(ncar-1)+1,ncar*ncar
          crhm(idx)=crsource(idx)+crfield(idx+ioff)
     +           +cstep(ihloop)*(crfield(idx-ncar+ioff)          !boundary: field = 0 for ix+ncar
     +           -2.*crfield(idx+ioff))
        end do
c
c
c     neumann boundary condition
c     ------------------------------------------------------------------
c 
      
      if (lbc.ne.0) then
         idx=ncar*(ncar-1)
         do ix=1,ncar
            crhm(ix)=crhm(ix)+cstep(ihloop)
     +	    *crfield(ix+ncar+ioff)
            crhm(idx+ix)=crhm(idx+ix)
     +	    +cstep(ihloop)*crfield(idx+ix-ncar+ioff)
         enddo
      endif
c
c     solve the tridiagonal system 1
c     ------------------------------------------------------------------

      call tridagx(crmatc,crhm,crfield,ihloop)      
c
c
c     homogenious part to right hand side of diff equation (2)
c     ------------------------------------------------------------------
c
c
      do ix=1,ncar*(ncar-1)+1,ncar
         crhm(ix)=crsource(ix)+crfield(ix+ioff)
     +           +cstep(ihloop)*(crfield(ix+1+ioff)
     +           -2.*crfield(ix+ioff))
         do idx=ix+1,ix+ncar-2
            crhm(idx)=crsource(idx)
     +                +crfield(idx+ioff)
     +                +cstep(ihloop)*(crfield(idx+1+ioff)
     +                +crfield(idx-1+ioff)
     +                -2.*crfield(idx+ioff))
         enddo
         idx=ix+ncar-1
         crhm(idx)=crsource(idx)+crfield(idx+ioff)
     +           +cstep(ihloop)*(crfield(idx-1+ioff)
     +           -2.*crfield(idx+ioff))
      enddo 
c
c
c     neumann boundary condition
c     ------------------------------------------------------------------
c
      if (lbc.ne.0) then
         do ix=1,ncar
            idx=ncar*(ix-1)+1
            crhm(idx)=crhm(idx)
     +	    +cstep(ihloop)*crfield(idx+1+ioff)
            idx=idx+ncar-1
            crhm(idx)=crhm(idx)
     +	    +cstep(ihloop)*crfield(idx-1+ioff)
         enddo
      endif
c
c     solve the tridiagonal system 2
c     ------------------------------------------------------------------
c
      call tridagy(crmatc,crhm,crfield,ihloop)
c
      return
      end     !fieldcar
c
c
      subroutine tridagx(c,r,u,h)
c     ==================================================================
c     solve a tridiagonal system for cartesian mesh in x direction
c     cbet and cwet are precalculated in auxval
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'field.cmn'

      integer k,i,h,ioff1,ioff2
      complex*16 c(*),r(*),u(*)
c
      ioff1=ncar*(h-1)
      ioff2=ncar*ioff1
c
      do i=0,ncar*(ncar-1),ncar
        u(i+1+ioff2)=r(i+1)*cbet(1+ioff1)
        do k=2,ncar
	  u(k+i+ioff2)=(r(k+i)-c(ioff1+k)
     +	  *u(k+i-1+ioff2))*cbet(k+ioff1)
        end do       ! k
        do k=ncar-1,1,-1
          u(k+i+ioff2)=u(k+i+ioff2)
     +	  -cwet(k+1+ioff1)*u(k+i+1+ioff2) 
        end do
      end do
c

      return
      end     !tridag
c
c
      subroutine tridagy(c,r,u,h)
c     tridagy(crmatc,crhm,crfield,ihloop)        
c     ==================================================================
c     solve a tridiagonal system for cartesian mesh in y direction
c     cbet and cwet are precalculated in auxval
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'field.cmn'
      include 'input.cmn'

      integer n,k,i,h,ioff1,ioff2
      complex*16 c(*),r(*),u(*)
c
      ioff1=ncar*(h-1)
      ioff2=ncar*ioff1
c
      do i=1,ncar
         u(i+ioff2)=r(i)*cbet(1+ioff1)
      enddo
      do k=2,ncar
         n=k*ncar-ncar
         do i=1,ncar
            u(n+i+ioff2)=(r(n+i)-c(ioff1+k)
     +	    *u(n+i-ncar+ioff2))*cbet(k+ioff1)
         enddo
      enddo
      do k=ncar-1,1,-1
         n=k*ncar-ncar 
         do i=1,ncar
            u(n+i+ioff2)=u(n+i+ioff2)
     +	    -cwet(k+1+ioff1)*u(n+i+ncar+ioff2)
         enddo
      enddo 
c
      return
      end     !tridag
c
c
c   
      subroutine getdiag(stepsize,gridsize,wavenumber)
c     ======================================================================
c     construct the diagonal matrix for field equation
c     do some precalculation for field solver
c     ----------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'field.cmn'
      include 'work.cmn'
c
      integer icar,ix,ihloop
      real*8 mupp,mmid,mlow,rtmp,stepsize,gridsize,wavenumber 
      complex*16  cwrk1(ncmax),cwrk2(ncmax)
      dimension mupp(ncmax),mmid(ncmax),mlow(ncmax)
     
c
c     construction of the diagonal maxtrix for cartesian mesh
c     --------------------------------------------------------------------
      do ihloop=1,nhloop
        rtmp=0.25d0*stepsize/(wavenumber*dble(hloop(ihloop)))
        rtmp=rtmp/(gridsize*gridsize)                !factor dz/(4 ks dx^2)
        cstep(ihloop)=dcmplx(0.d0,rtmp)    !complex value - see field equation  
        if (lbc.ne.0) lbc=1        !boundary condition
        mupp(1)=rtmp         !one edge of mesh 
        mmid(1)=-dble(2-lbc)*rtmp   !boundary condition a=0 or da/dz=0 
        mlow(1)=0.d0          
        do ix=2,ncar-1
          mupp(ix)=rtmp        !inside of mesh -> 2nd derivation possible
          mmid(ix)=-2.d0*rtmp
          mlow(ix)=rtmp
        end do
        mupp(ncar)=0.d0       !other edge of mesh
        mmid(ncar)=-dble(2-lbc)*rtmp
        mlow(ncar)=rtmp
c
c     construct complex matrix crmat=(i-im) for
c     field equation  (i-im)*a(t+1)=(i+im)a(t)
c     -------------------------------------------------------------------------
c
        do icar=1,ncar
          cwrk1(icar)=-dcmplx(0.d0,mupp(icar))            !store value temporary in cwrk1
          cwrk2(icar)=(1.d0,0.d0)-dcmplx(0.d0,mmid(icar)) !same here
          crmatc(ncar*(ihloop-1)+icar)=-dcmplx(0.d0,mlow(icar))            !crmatc is used later in the code
        end do
c                                         
c     precalculated constants for tridiag subroutine
c     ------------------------------------------------------------------------ 

          cbet((ihloop-1)*ncar+1)=1./cwrk2(1)
          cwet((ihloop-1)*ncar+1)=0.
         do icar=2,ncar
	    cwet((ihloop-1)*ncar+icar)=cwrk1(icar-1)
     +	    *cbet((ihloop-1)*ncar+icar-1)
	    cbet((ihloop-1)*ncar+icar)=1./(cwrk2(icar)-
     +	    crmatc(ncar*(ihloop-1)+icar)*cwet((ihloop-1)*ncar+icar)) 
	 end do
      end do
      return
      end     !auxval
c
::::::::::::::
fort2cpp.f
::::::::::::::
c      ============================================
c      various to access data from fortran common block to C++
c

c----------------------------------------------
c      field access functions
c
       

       function f2cgetslippagefield(values,irec,dims)
       include 'genesis.def'
       include 'field.cmn'
       include 'sim.cmn'
       include 'input.cmn'
       include 'work.cmn'
       integer f2cgetslippagefield,dims,i,irec
       real*8 values(*),scl

       f2cgetslippagefield=1
       scl=xkw0*xkw0 
       call pulltimerec(crwork3,ncar,irec)
       do i=1,ncar*ncar*dims
         values(2*i-1)=dreal(crwork3(i))*scl
         values(2*i)  =dimag(crwork3(i))*scl
       enddo
       return
       end


       function f2cgetfullfield(values,dims,idx)
       include 'genesis.def'
       include 'field.cmn'
       include 'sim.cmn'
       include 'input.cmn'
       integer f2cgetfullfield,dims,i,offset,idx
       real*8 values(*),scl

       offset=ncar*ncar*(idx-1)
       f2cgetfullfield=1 
       scl=xkw0*xkw0
       do i=1,ncar*ncar*dims
         values(2*i-1)=dreal(crfield(i+offset))*scl
         values(2*i)  =dimag(crfield(i+offset))*scl
       enddo
       return
       end

       function f2cputfullfield(values,dims,idx)
       include 'genesis.def'
       include 'field.cmn'
       include 'sim.cmn'
       include 'input.cmn'
       integer f2cputfullfield,dims,i,offset,idx
       real*8 values(*),scl

       offset=ncar*ncar*(idx-1)
       f2cputfullfield=1 
       scl=1./xkw0/xkw0
       do i=1,ncar*ncar*dims
         crfield(offset+i)=dcmplx(values(2*i-1),values(2*i))*scl
     c   
       enddo
       return
       end

c-------------------------------
c      beam access functions
c

c----------------------------------
c
c      note that the transverse positions are not scaled with xkw0. This is done in readpart!

       function f2cputbeam(values,dims)
       include 'genesis.def'
       include 'particle.cmn'
       include 'sim.cmn'
       include 'input.cmn'
       integer f2cputbeam,dims,i
       real*8 values(*)
c       dimension values(npmax)
       f2cputbeam=1 
       if (dims.eq.1) then  
          do i=1,npart
             gamma(i)=values(i)
          enddo
          return
       endif
       if (dims.eq.2) then  
          do i=1,npart
             theta(i)=values(i)
          enddo
          return
       endif
       if (dims.eq.3) then  
          do i=1,npart
             xpart(i)=values(i)*xkw0
          enddo
          return
       endif
       if (dims.eq.4) then  
          do i=1,npart
             ypart(i)=values(i)*xkw0
          enddo
          return
       endif
       if (dims.eq.5) then  
          do i=1,npart
             px(i)=values(i)
          enddo
          return
       endif
       if (dims.eq.6) then  
          do i=1,npart
             py(i)=values(i)
          enddo
          return
       endif
       return
       end

c-------------------------------------------------------

       function f2cgetbeam(values)
       include 'genesis.def'
       include 'particle.cmn'
       include 'sim.cmn'
       include 'input.cmn'
       integer f2cgetbeam,dims,i
       real*8 values(*)
c       dimension values(npmax)
       f2cgetbeam=1 
       do i=1,npart
          values(i)=gamma(i)
       enddo
       do i=1,npart
          values(i+npart)=theta(i)
       enddo
       do i=1,npart
          values(i+2*npart)=xpart(i)/xkw0
       enddo
       do i=1,npart
          values(i+3*npart)=ypart(i)/xkw0
       enddo
       do i=1,npart
          values(i+4*npart)=px(i)
       enddo
       do i=1,npart
          values(i+5*npart)=py(i)
       enddo
       
       return
       end


c--------------------------------------------
       function f2cgetdiagnorecord(ir,values)
       include 'genesis.def'
       include 'diagnostic.cmn'
       integer f2cgetdiagnorecord
       real*8 values
       integer ir,i
       dimension values(nhmax*10+10)
       f2cgetdiagnorecord=0
       values(1)=pgainhist(1,ir)
       values(2)=logp(ir)
       values(3)=pmidhist(1,ir)
       values(4)=phimid(1,ir)  
       values(5)=whalf(ir)
       values(6)=diver(ir)
       values(7)=gamhist(ir)
       values(8)=pmodhist(1,ir)
       values(9)=xrms(ir)
       values(10)=yrms(ir)
       values(11)=error(ir)
       values(12)=xpos(ir)
       values(13)=ypos(ir)
       values(14)=dgamhist(ir)
       values(15)=ffield(1,ir)
       values(16)=bunphase(1,ir)
       do i=2,nhmax
         values((i-2)*5+17)=pmodhist(i,ir)
         values((i-2)*5+18)=pgainhist(i,ir)
         values((i-2)*5+19)=bunphase(i,ir)
         values((i-2)*5+20)=pmidhist(i,ir)
         values((i-2)*5+21)=phimid(i,ir)
       enddo
       return
       end
c-------------------------------------------
       function f2cgetmaglattice(awc,qfc)
       include 'genesis.def'
       include 'magnet.cmn'
       include 'input.cmn'
       integer i
       real*8 f2cgetmaglattice,awc,qfc
       dimension awc(nzmax),qfc(nzmax)
       f2cgetmaglattice=delz*xlamd
       do i=0,nstepz
         awc(i+1)=awz(i)
         qfc(i+1)=qfld(i)/586.
       enddo
       return 
       end

       function f2cgetscanvalue()
       include 'genesis.def'
       include 'sim.cmn'
       real*8 f2cgetscanvalue
       f2cgetscanvalue=svalout
       return
       end

       function f2cgetcurrent()
       include 'genesis.def'
       include 'particle.cmn'
       real*8 f2cgetcurrent
       f2cgetcurrent=xcuren
       return
       end

       function f2cputcurrent(cur)
       include 'genesis.def'
       include 'particle.cmn'
       integer f2cputcurrent
       real*8 cur
       f2cputcurrent=0
       xcuren=cur
       return
       end

c-----------------------
       function f2cputnpart0(n)
       include 'genesis.def'
       include 'sim.cmn'
       include 'input.cmn'
       integer f2cputnpart0,n
       f2cputnpart0=0
       npart0=n
       npart=n
       return
       end
     
       function f2cgetdxy()
       include 'genesis.def'
       include 'field.cmn'
       real*8 f2cgetdxy
       f2cgetdxy=dxy
       return 
       end


       function f2cgetxkw0()
       include 'genesis.def'
       include 'sim.cmn'
       real*8 f2cgetxkw0
       f2cgetxkw0=xkw0
       return 
       end


       function f2cgetnslp()
       include 'genesis.def'
       include 'time.cmn'   
       integer f2cgetnslp
       f2cgetnslp=nslp
       return 
       end

       function f2cgetnsep()
       include 'genesis.def'
       include 'time.cmn'   
       integer f2cgetnsep
       f2cgetnsep=nsep
       return 
       end



       function f2cgetnstepz()
       include 'genesis.def'
       include 'magnet.cmn'   
       integer f2cgetnstepz
       f2cgetnstepz=nstepz
       return 
       end

       function f2cgetoutputfilename(string)
       include 'genesis.def'
       include 'input.cmn'
       character string*(*)
       integer f2cgetoutputfilename,i
       f2cgetoutputfilename=strlen(outputfile)
       do i=1,strlen(outputfile)
         string(i:i)=outputfile(i:i)
       enddo
       return
       end

       function f2cgetpartfilename(string)
       include 'genesis.def'
       include 'input.cmn'
       character string*(*)
       integer f2cgetpartfilename,i
       f2cgetpartfilename=strlen(partfile)
       do i=1,strlen(partfile)
         string(i:i)=partfile(i:i)
       enddo
       return
       end

       function f2cgetfieldfilename(string)
       include 'genesis.def'
       include 'input.cmn'
       character string*(*)
       integer f2cgetfieldfilename,i
       f2cgetfieldfilename=strlen(fieldfile)
       do i=1,strlen(fieldfile)
         string(i:i)=fieldfile(i:i)
       enddo
       return
       end

       function f2cgetfieldharmfilename(string)
       include 'genesis.def'
       include 'input.cmn'
       character string*(*)
       integer f2cgetfieldharmfilename,i
       f2cgetfieldharmfilename=strlen(fieldharmfile)
       do i=1,strlen(fieldharmfile)
         string(i:i)=fieldharmfile(i:i)
       enddo
       return
       end
::::::::::::::
importbeam.f
::::::::::::::

c
      subroutine importdispersion 
c     ================================================================= 
c     apply dispersion to imported beam file from readpart
c     subroutine supplied by Atoosa Meseck from Bessy
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
c
      real*8 iarho,iaphi,mam,imagl_old
      real*8 ypart_old,py_old
      real*8 ma12,ma33,ma34,ma43,ma56
      integer i,ierr
c
      if (ibfield.eq.0.d0) return                     
      if (idril.lt.0.d0) then                      
          ierr=printerr(errinwarn,'IDRIL<0-NO DISP.SECTION')                                     
          return
      endif  
c
      if (igamref.le.0) igamref=gamma0  
c          
      ibfield=abs(ibfield)      
c      
      imagl_old=imagl
      iarho=(igamref*5.11e-04)/(ibfield*0.299793)
      iaphi= asin(imagl/iarho)
      mam=tan(iaphi)/iarho
      imagl=iaphi*iarho 

      ma12=3*idril+4*iarho*sin(iaphi)*cos(iaphi)
     +      +2*idril*cos(iaphi)*cos(iaphi)
           
      ma33= mam*(-10*idril-8*imagl)+
     +      mam*mam*(26*imagl*idril+
     +      15*idril*idril+8*imagl*imagl)+
     +      mam**3*(-12*idril*(imagl**2)-
     +      20*(idril**2)*imagl-7*(idril)**3)
     +      +1+(mam**4)*(4*(idril)**3*imagl+
     +      (2*idril*imagl)**2+idril**4)
           
c ma44=ma33 
           
      ma34=mam*(-28*idril*imagl-
     +      8*(imagl)**2-20*(idril)**2)+
     +      mam*mam*(44*imagl*(idril)**2+
     +      21*(idril)**3+20*idril*imagl**2)+
     +      mam**3*(-16*(idril*imagl)**2-
     +      24*(idril**3)*imagl-8*(idril)**4)
     +      +(mam**4)*(4*(idril)**3*imagl**2+
     +      4*idril**4*imagl+idril**5)+
     +      5*idril+4*imagl

      ma43=tan(iaphi)*(-2*iarho+
     +      2*tan(iaphi)*imagl+tan(iaphi)*idril)*
     +      (2*iarho**2-4*tan(iaphi)*imagl*iarho-
     +      4*tan(iaphi)*idril*iarho+
     +      2*idril*tan(iaphi)*tan(iaphi)*imagl+
     +      (tan(iaphi)*idril)**2)/
     +      iarho**4 


      ma56=8*iarho*sin(iaphi)-
     +      4*iarho*sin(iaphi)*cos(iaphi)+2*idril-
     +      2*idril*cos(iaphi)*cos(iaphi)-4*imagl+
     +      ((5*idril+4*imagl)/igamref**2) 
c
      imagl=imagl_old
c
      do i=1,npart 
           theta(i)=theta(i)+
     +      (ma56*(gamma(i)-igamref)/igamref)*twopi/xlamds/convharm
           xpart(i)=xpart(i)+ma12*px(i)/gamma(i)
           ypart_old=ypart(i)
           py_old= py(i)
           ypart(i)=ma33*ypart_old+ma34*py_old/gamma(i)         
           py(i)=ma43*ypart_old*gamma(i)+ma33*py_old 
      enddo                                       
      return
      end !of import dispersion
c
c      
      subroutine importtransfer 
c     ================================================================= 
c     Transfer matrix calculation supplied by A. Meseck. 
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'io.cmn'
      include 'input.cmn'
      include 'field.cmn'
      include 'sim.cmn'
      include 'particle.cmn'
c
      real*8 ypart_old,py_old,xpart_old,px_old
      real*8 gamma_old,theta_old    
      integer i,ierr
c
      if (trama.eq.0.d0) return
      if (igamref.le.0) igamref=gamma0 

      do i=1,npart 
c  Denormalize      
         px(i)=px(i)/gamma(i)
         py(i)=py(i)/gamma(i)
cc
         xpart_old=xpart(i)
         ypart_old=ypart(i)
         px_old= px(i)
         py_old= py(i)
         theta_old=theta(i)
         gamma_old= gamma(i)

            xpart(i)=itram11*xpart_old+itram12*px_old+
     +      itram13*ypart_old+itram14*py_old+
     +      itram15*theta(i)*xlamds*convharm/twopi+
     +      itram16*(gamma(i)-igamref)/igamref

           px(i)=itram21*xpart_old+itram22*px_old+
     +      itram23*ypart_old+itram24*py_old+
     +      itram25*theta_old*xlamds*convharm/twopi+
     +      itram26*(gamma(i)-igamref)/igamref

         
           ypart(i)=itram31*xpart_old+itram32*px_old+
     +      itram33*ypart_old+itram34*py_old+
     +      itram35*theta_old*xlamds*convharm/twopi+
     +      itram36*(gamma(i)-igamref)/igamref

           py(i)=itram41*xpart_old+itram42*px_old+
     +      itram43*ypart_old+itram44*py_old+
     +      itram45*theta_old*xlamds*convharm/twopi+
     +      itram46*(gamma(i)-igamref)/igamref

          theta(i)=itram55*theta_old+ (itram56*
     +    ((gamma(i)-igamref)/igamref)*twopi/xlamds/convharm)+
     +    (itram51*xpart_old+itram52*px_old+itram53*ypart_old+
     +     itram54*py_old)*twopi/xlamds/convharm

         gamma(i)=(itram61*xpart_old+itram62*px_old+
     +      itram63*ypart_old+itram64*py_old+
     +      itram65*theta_old*xlamds*convharm/twopi)*
     +      igamref + itram66*(gamma(i)-igamref)+igamref

c normalization
           px(i)=px(i)*gamma(i)
           py(i)=py(i)*gamma(i)
cc
      enddo    
                                                                 
      return
      end !of import transfermatrix
c
c            
      function readpart(nread)
c     =================================================================
c     load complete set of particle from file
c     -----------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
      include 'io.cmn' 
      include 'sim.cmn'
c
      integer j,i,islice,idel,nread
c

      logical isop
c
      readpart=noerr
      npart0=nread
      npart=nread     !  needed to reset the counter when imported from partfile.

c     apply transfermatrix to particle distribution
      call importtransfer 
c  
c     dispersive section
      call importdispersion    
c
c
c     convert to higher harmonic
c
      if (convharm.gt.1) then
            do i=1,npart
             theta(i)=float(convharm)*theta(i)
            enddo 
      endif
c
c     calculate init. perpendicular velocity (needed in first call of track)
c
      do i=1,npart0      
	btpar(i)=dsqrt(1.d0-(px(i)**2+py(i)**2+1.)/gamma(i)**2)     !parallel velocity
      enddo
c
c     check for particle losses from previous run
c
      idel=0          
      do i=1,npart 
         if (gamma(i).gt.0.) then
            gamma(i-idel)=gamma(i)  
            theta(i-idel)=theta(i)  
            xpart(i-idel)=xpart(i)
            ypart(i-idel)=ypart(i)
            px(i-idel)=px(i)
            py(i-idel)=py(i)
            btpar(i-idel)=btpar(i)
         else    
            idel=idel+1
         endif
      enddo
      npart=npart0-idel
      xcuren=xcuren*float(npart)/float(npart0)
      call chk_loss


c
      return
 100  readpart=printerr(errread,partfile)
      call last
      return
      end
c

::::::::::::::
incoherent.f
::::::::::::::

      subroutine incoherent(awz)
c     ==================================================================
c     compute elnergy lost and spread due to synchrtron radiation
c     only correct for planar undulators (almost correct for helical)
c     from  draft by s. reichle, modified by p. elleaume  august 1999
c     the effect ofenergy loss and spread  has been tested successfully
c     with respect to e. saldin nima381 (1996) p 545-547
c     ------------------------------------------------------------------
c
c
      include  'genesis.def'
      include  'input.cmn'
      include  'particle.cmn'
c
      integer ip,mpart,k
      real*8 tmp2,gam0,dgamavg,dgamsig,xkw0,awz
c
      if (awz.lt.tiny) return  !drift section!
      if ((isravg.eq.0).and.(isrsig.eq.0)) return 
c
      xkw0=twopi/xlamd
      gam0=0.
      do ip=1,npart
         gam0=gam0+gamma(ip)
      enddo
      gam0=gam0/dble(npart)
c
c     increase of energy spread
c
      dgamsig=1.015d-27*(xkw0*awz)**2*(1.697*awz+
     +     1./(1.+1.88*awz+0.8*awz**2)) 
      if (iwityp.ne.0) then                              !helical undulator
         dgamsig=1.015d-27*(xkw0*awz)**2*(1.42*awz+
     +           1./(1.+1.5*awz+0.95*awz**2))
      endif
c
      dgamsig=dsqrt(dgamsig*gam0**4*xkw0*xlamd*delz)*sqrt(3.)
     c        *dble(isrsig) !sqrt(3) uniform distribution
c
c     average energy loss
c
      dgamavg=1.88d-15*(xkw0*gam0*awz)**2
     c        *delz*xlamd*dble(isravg)
c
      mpart=npart/dble(nbins)
      gam0=0.
      if  (isrsig.ne. 0) then
          do ip=1,mpart
             tmp2=(2.*ran1(iseed)-1.)*dgamsig
             gam0=gam0+tmp2
             do k=0,nbins-1
               gamma(ip+k*mpart)=gamma(ip+k*mpart)+tmp2
             enddo  
          enddo
      endif
      gam0=gam0/dble(mpart)
      if (gam0+dgamavg .ne. 0.) then
         do ip=1,npart
            gamma(ip)=gamma(ip)-gam0-dgamavg
         enddo
      endif
c
      return
      end     !sr
c


::::::::::::::
initrun.f
::::::::::::::
      function initrun()
c     ==================================================================
c     initialize the run by setting up
c     the precalculated matrices for the field solver and
c     claculating/normalizing some auxiliary variables
c
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
      include 'sim.cmn'
      include 'field.cmn'
      include 'time.cmn'
      include 'magnet.cmn'
c
      real*8 xi,initrun,rslp
      integer ip,i
c
c     seeding of random number generator
c
      initrun=0
      xi=ran1(iseed)          !init ran1
c
c      initiate loop for higher harmonics
c

c
      dedz=eloss*delz*xlamd/eev
      xcuren=curpeak
      npart0=npart                            !save total number or particle 
      if (ione4one.ne.0) then                 !one 4 one simulation. Calculate particle number.
        npart=curpeak*xlamds*zsep/ce
        npart0=npart
      endif
c
c     normalizations
c     ------------------------------------------------------------------
c
      xkw0= twopi/xlamd                       !wiggler wavenumber
      xkper0 = xkw0                           !transverse normalisation
c
c     magnetic field
c     ------------------------------------------------------------------   
c
      call magfield(xkper0,1)                   !magnetic field description
c
      if (inorun.ne.0) then
        ip=PRINTERR(ERRGENWARN,'Termination enforced by user')
        call last
      endif
 
c
c     slipping length
c
      nsep=int(zsep/delz)                      !steps between field slippage
      if (nsep.lt.1) nsep=1
      rslp=0;
      do i=1,nstepz
        rslp=rslp+awslip(i)
      enddo
      rslp=rslp/zsep
      nslp=int(rslp/nsep)                         !total slippage steps
      if (mod(nstepz,nsep).ne.0) nslp=nslp+1   !if not added the effective undulator
c      write(*,*) 'nstepz: ',nstepz, ' nslp: ', nslp
c                                              !would be shorter
c     contruct grid properties (grid spacing, precalculated matrices)
c
      dxy=xkw0*2.d0*dgrid/float(ncar-1)    
      xks=twopi/xlamds

c
c     time dependencies
c
      call loadslpfld(nslp)        !input field for first slice and seeding of ran-function
c
c     scanning
c
      call scaninit   !initialize scanning
c
c      
c
c     matrix initialization
      call getdiag(delz*xlamd,dxy/xkper0,xks)
c
c     clear space charge field for case that space charge is disabled
c
      do ip=1,npart   !clear space charge term
         ez(ip)=0.d0
      end do       ! ip

c
c
      return
      end
c
::::::::::::::
input.f
::::::::::::::
      function initio()
c     ==================================================================
c     manages all initial input for genesis
c     ------------------------------------------------------------------

      include 'genesis.def'
      include 'input.cmn'
      include 'io.cmn'
      include 'mpi.cmn'
      include 'field.cmn'

      integer ierr1,ierr2,i,ih,initio
      character*34 file
      character*11  file_id
      character*4   file_ext
c
      initio=0
      nprobe=30                          !filenumber for filetype probing
      nlog=6
      call first
      ierr1=0
c
      call touppercase(filetype)              !convert to upper case letter
      ftype=original
      i=index(filetype,'SDDS')
      if (i.gt.0) ftype=f_sdds
  
c
      if (ilog.ne.0) then
        if (index(outputfile,' ').eq.1) then
         file='log-file'
         goto 5
        else   
         file_id=''
         if (mpi_size.gt.1) then
           write(file_id,2) mpi_id         ! apppend process ID if run in MPI
         endif
 2       format('.node',I6.6)
         file=outputfile(1:strlen(outputfile))//'.log'//file_id         
         write(*,*) 'logfile: ',file
        endif   
        open(16,file=file,status='unknown',err=5)
        nlog=16
 5      if (nlog.eq.6)  i=printerr(erropen,file)
      endif
c
c     changed to output in C++
c
c      ierr2=openoutputfile(ierr1,'template.in')        !open outputfile+dump namelist
c      if ((ierr2+ierr1).lt.0) call last  !error occured?
c
      call chk_input                     !make input consistent
c
c     changed to output in C++
c
c     open addition output files
c
c      if (ipradi.gt.0) then !is output of radiation field selected?
c         irecfld=1
c         nfld =openbinfile(outputfile,'fld '
c     +                       ,10,8*ncar*ncar) !real and imag seprated
c         do ih=2,nhloop 
c           write(file_ext,100) 'fld',hloop(ih)
c           nfldh(ih-1) =openbinfile(outputfile,file_ext,
c     +                                 20+ih,8*ncar*ncar)	
c	 enddo 
c      else
c         nfld=-1
c      endif 
c 100  format(A3,I1.1)
c
c      if (ippart.gt.0) then  !is output of particle distribution desired?
c         irecpar=1
c         npar =openbinfile(outputfile,'par ',11,8*npart)
c      else
c         npar=-1
c      endif
c
c     changed to output in C++
c
c      if (idmpfld.ne.0) then   !dumped radiation field?
c         ndump=openbinfile(outputfile,'dfl ',12,16*ncar*ncar)
c	 do ih=2,nhloop
c           write(file_ext,100) 'dfl',hloop(ih)
c           ndumph(ih-1)=
c     +         openbinfile(outputfile,file_ext,30+ih,16*ncar*ncar)
c	 enddo
c      else
c         ndump=-1
c      endif
c       
c      if (idmppar.ne.0) then   !should the radiation field be dumped at the end?
c         ndmp2=openbinfile(outputfile,'dpa ',13,8*npart)
c      else
c         ndmp2=-1
c      endif
c
      if (itdp.ne.0) call opentimerec(ncar)          !prepare the crtime-record
c
c     open additional input files (maginfile is opened in magfield.f)
c
      call readbeamfile(beamfile)   !read external description file for beam 
      call readradfile(radfile)		!read external description file for radiation profile
c
      nfin=checkbininput(fieldfile,14)! returns -1 if no name specified
      npin=checkbininput(partfile,15)      ! ---------- " ----------
      ndis=readdistfile(distfile,17)                ! ---------- " ----------
c
c     check for boundary violation or unphysical input parameters
c
      ierr1=chk_bnd()           !check for boundary violation
      if (ierr1.lt.0) call last
c
      return
c

      end  !of ioinit
c
      function checkbininput(file,nio)
c     =================================================================
c     checks for binary input files (filed and part files) and checks for 
c     the filetype
c     -----------------------------------------------------------------
c
      include 'genesis.def'
      include 'io.cmn'
c
      character*(*) file
      integer nio

      checkbininput=-1
      if (index(file,' ').eq.1) return   !no file selected
      checkbininput=nio

      return   ! input is done now in C++

      end
c      
c
      function detectfiletype(filename)
c     =================================================================
c     the routine tries to read the beginning of the file
c     if the first line contains sdds then it returns the constant 
c     sdds, otherwise it returns the constant original
c     ----------------------------------------------------------------
c
      include 'genesis.def'
      include 'io.cmn'

      character*80 line
      character*(*) filename
      integer i
c
      detectfiletype=original
      return
      open(nprobe,file=filename,status='old',err=100)
      read(nprobe,200,err=110) line
      close(nprobe)
      call touppercase(line)
      i=index(line,'SDDS')
      if (i.gt.0) detectfiletype=f_sdds
      return
c      
 100  detectfiletype=printerr(erropen,filename) 
      call last     
      return
 110  detectfiletype=printerr(errread,filename)
      call last      
      return
 200  format(a)
c
      end ! of detectfiletype
c
c
      function readin(filename_in,nlen)
c     =================================================================
c     this routine reads in the user input files.
c     it assumes the standard fortran namelist format.
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
c
      integer nin,nlen
      character*(*) filename_in
c
      namelist /newrun/
c
c     wiggler        
     +          aw0,xkx,xky,wcoefz,xlamd,fbess0,delaw,iertyp,iwityp,
     +          awd,iseed,awx,awy,phaseshift,
c     electron beam
     +          npart,gamma0,delgam,rxbeam,rybeam,alphax,alphay,
     +          emitx,emity,xbeam,ybeam,pxbeam,pybeam,cuttail,curpeak,
     +          conditx,condity,bunch,bunchphase,emod,emodphase,
c     radiation
     +          xlamds,prad0,zrayl,zwaist,pradh0,
c     grid-quantities   
     +          ncar,lbc,rmax0,dgrid,nscr,nscz,nptr,rmax0sc,iscrkup,
c     control
     +          nwig,delz,zsep,nsec,iorb,zstop,magin,magout,nbins,
     +          version,iautophase,
c     strong focusing
     +          quadf,quadd,fl,dl,drl,f1st,qfdx,qfdy,sl,solen,
c     loading 
     +          ildgam,ildpsi,ildx,ildy,ildpx,ildpy,itgaus,lout,
     +          igamgaus,inverfc,ione4one,
c     output
     +          iphsty,ishsty,ippart,ispart,ipradi,isradi,
     +          idump,iotail,nharm,iallharm,iharmsc,idmppar,
     +          idmpfld,ilog,ffspec,
c     external files
     +          beamfile,fieldfile,maginfile,magoutfile,outputfile, 
     +          partfile,distfile,filetype,radfile,fieldharmfile,
c     time-dependency
     +          curlen,ntail,nslice,shotnoise,iall,itdp,ipseed,isntyp,  
c     scan
     +          iscan,nscan,svar,scan,  
c     extension
     +          isravg,isrsig,eloss,ndcut,ibfield,imagl,idril,convharm,
     +          alignradf,offsetradf,multconv,igamref,
c     transfermatrix
     +          trama,itram11,itram12,itram13,itram14,itram15,itram16,
     +          itram21,itram22,itram23,itram24,itram25,itram26,
     +          itram31,itram32,itram33,itram34,itram35,itram36,
     +          itram41,itram42,itram43,itram44,itram45,itram46,
     +          itram51,itram52,itram53,itram54,itram55,itram56,
     +          itram61,itram62,itram63,itram64,itram65,itram66
c     temporary included parameter

c
c     initialize input/output
c
      inputfile=filename_in(1:nlen)
c
      nin=8
      readin=noerr
      call preset               ! default values
c
      open(nin,file=inputfile,err=10,status='old') !open input file.
      read(nin,newrun,err=20,end=20)                      !read in namelist
      close(nin)                                   !close file 
      return
c
 10   readin=printerr(erropenin,inputfile)
      return
 20   readin=printerr(errreadin,inputfile)
      return
      end   !readin
c
      subroutine readbeamfile(file)
c     =============================================================
c     read the file for external description of the electron beam
c     -------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'time.cmn'
      include 'io.cmn'
c
      integer nin,i,ncol,ipar(15),ix,idata,j,ft,itmp
      character*(*) file
      character*50 cerr
      character*511 line
      real*8  ver,values(15),tmin,tmax,reverse
c
      itmp=0
      ndata=-1           
      if (index(file,' ').eq.1) return
c
      if ((iscan.gt.0).and.(iscan.lt.23)) then
          i=printerr(errscanex,file)
          return
      endif    
c
c     read file
c
      ft=detectfiletype(file)        ! check for filetype
c
      nin=opentextfile(file,'old',8)
      if (nin.lt.0) call last ! stop program on error
c
      ndata=-1            !# of rows not defined
      idata=0             !# of rows read
      ncol =15            !# of elements per line
      reverse=1.0         !tail for ZPOS and head for TPOS comes first in file
      ver=0.1
      do i=1,ncol
         ipar(i)=i        !basic order of input
      enddo
c
 1    read(nin,100,err=20,end=50) line
c
c     processing line
c     
      call touppercase(line)
      call getfirstchar(line,ix)
c
      if (ix.eq.0) goto 1                     !empty line
      if (line(ix:ix).eq.'#') goto 1          !no comment used
      if (line(ix:ix).eq.'?') then
         call getbeamfileinfo(line,ipar,ncol,ndata,ver,reverse)  !check for add. info
         goto 1
      endif
c
      if ((ndata.lt.0).and.(ver.lt.1.0)) then !old version
         i=extractval(line,values,1)
         if (i.lt.0) then
            write(cerr,*) 'Line number of BEAMFILE cannot be determined'
            i=printerr(errinput,cerr)
         endif
         ndata=nint(values(1))
         goto 1
      endif
c
      i=extractval(line,values,ncol)
      if (i.lt.0) then
        write(cerr,*) 'BEAMFILE data line ',idata+1,' has bad format'
        i=printerr(errinput,cerr)
        call last
      endif
c
      idata=idata+1
c
c     set default values      
c
      tpos(idata)=xlamds*zsep*idata    !can we make this the default?
      tgam0(idata)=gamma0
      tdgam(idata)=delgam
      temitx(idata)=emitx
      temity(idata)=emity
      txrms(idata)=rxbeam
      tyrms(idata)=rybeam 
      txpos(idata)=xbeam
      typos(idata)=ybeam
      tpxpos(idata)=pxbeam
      tpypos(idata)=pybeam
      talphx(idata)=alphax
      talphy(idata)=alphay
      tcurrent(idata)=curpeak
      tloss(idata)=eloss
c
c     write over with input data
c
      do j=1,ncol
         if (ipar(j).eq.1 ) tpos(idata)    = reverse*values(j)
         if (ipar(j).eq.-1) tpos(idata)    =-reverse*values(j)*3e8  ! time input
         if (ipar(j).eq.2 ) tgam0(idata)   = values(j)
         if (ipar(j).eq.3 ) tdgam(idata)   = values(j)
         if (ipar(j).eq.4 ) temitx(idata)  = values(j)
         if (ipar(j).eq.5 ) temity(idata)  = values(j)
         if (abs(ipar(j)).eq.6 ) txrms(idata)   = values(j) ! save for dual input
         if (abs(ipar(j)).eq.7 ) tyrms(idata)   = values(j) ! RXBEAM/BETAX
         if (ipar(j).eq.8 ) txpos(idata)   = values(j)
         if (ipar(j).eq.9 ) typos(idata)   = values(j)
         if (abs(ipar(j)).eq.10) tpxpos(idata)  = values(j) ! save for dual input
         if (abs(ipar(j)).eq.11) tpypos(idata)  = values(j) ! PXBEAM/XPRIME
         if (ipar(j).eq.12) talphx(idata)  = values(j)
         if (ipar(j).eq.13) talphy(idata)  = values(j)
         if (ipar(j).eq.14) tcurrent(idata)= values(j)
         if (ipar(j).eq.15) tloss(idata)   = values(j)
      enddo 
c
c     check for unphysical parameters
c
      if ((tgam0(idata)-4*abs(tdgam(idata))).lt.1) then
         itmp=printerr(errinput,'Energy GAMMA0 too small in BEAMFILE')  !abort
      else
        do j=1,ncol           ! calculate beam sizes (avods floating point exception
          if (ipar(j).eq.-6 )
     c     txrms(idata)=sqrt(txrms(idata)*temitx(idata)/tgam0(idata))
          if (ipar(j).eq.-7 )
     c     tyrms(idata)=sqrt(tyrms(idata)*temity(idata)/tgam0(idata))
           if (ipar(j).eq.-10 )
     c     tpxpos(idata)=tpxpos(idata)*tgam0(idata)
          if (ipar(j).eq.-11 )
     c     tpypos(idata)=tpypos(idata)*tgam0(idata)
        enddo
      endif  
c
      if (tcurrent(idata).lt.0) then
         itmp=printerr(errinput,'Current negative in BEAMFILE')  !abort
      endif 
c
      if (temitx(idata).lt.0) then
         itmp=printerr(errinput,'EMITX negative in BEAMFILE')  !abort
      endif 
c
      if (temity(idata).lt.0) then
         itmp=printerr(errinput,'EMITY negative in BEAMFILE')  !abort
      endif 
c
      if (idata.eq.1) then
         tmin=tpos(idata)
         tmax=tpos(idata)
      else
         if (tpos(idata).gt.tmax) tmax=tpos(idata)
         if (tpos(idata).lt.tmin) tmin=tpos(idata)
      endif
c
      goto 1
c
 50   close(nin)
c 
      if ((ndata.ge.0).and.(idata.ne.ndata)) then
         i=printerr(errinwarn,'BEAMFILE has fewer lines than defined')
      endif
      ndata=idata
      if (idata.lt.2) then
       i=printerr(errinput,'BEAMFILE contains less than 2 valid lines')
       call last
      endif
      if (itmp.ne.0) then
       call last
      endif
c
      if (ver.ge.1.0) then
        do i=1,ndata
          tpos(i)=tpos(i)-tmin   !set time window to zero
        enddo
      endif
c
      if (nslice.le.0) then
         nslice=int((tmax-tmin)/xlamds/zsep)
         if (ver.ge.1.0) then
           ntail=0
         else
           ntail=int(tmin/xlamds/zsep)
         endif
         write(ilog,110) nslice,ntail
      endif
c
      return
c
 20   i=printerr(errread,file)
      close(nin)
      call last
      return
c
c     format statement
c
 100  format(a)
 110  format('Auto-adjustment of time window:',/,
     c       'nslice=',i6,/ 
     c       'ntail =',i6)
c
      end     !readbeamfile
c 
      subroutine getbeamfileinfo(line,ipar,ncol,ndata,ver,reverse)
c     =================================================================
c     extract information from beamfile
c     -----------------------------------------------------------------
c
      include 'genesis.def'
c
      character*(*) line
      character*511 cline
      integer ndata,ipar(*),i,n,ncol,ierr,j,ix1,ix2,haszpos,iarg
      real*8  ver,val,reverse
c
c     version number
c
      i=index(line,'VERSION') !check for version number
      n=len(line)
      if (i.gt.0) then
        ierr=extractnumber(line(i+7:n),val)
        if (ierr.lt.0) then
           i=printerr(errinwarn,
     c               'Unrecognized information line in BEAMFILE')
        else
           ver=val
        endif
        return
      endif 
c
c     reverse order
c
      i=index(line,'REVERSE')
      n=len(line)
      if (i.gt.0) then
         reverse=-1.
         return
      endif
c         
c     line numbers
c
      i=index(line,'SIZE') !check for size argument (aka ndata)
      if (i.gt.0) then
        ierr=extractnumber(line(i+4:n),val)
        if (ierr.lt.0) then
           i=printerr(errinwarn,
     c               'Unrecognized information line in BEAMFILE')
        else
           ndata=nint(val)
        endif
        return
      endif
c
c     colum order
c
      i=index(line,'COLUMNS') !check for colums headers
      if (i.gt.0) then
         do j=1,15
            ipar(j)=0
         enddo
         ncol=0
         cline=line(i+7:n)
         haszpos=0
 1       call getfirstchar(cline,ix1)
         if (ix1.gt.0) then
           ix2=255             !search backwards
           do j=255,ix1+1,-1   !for first space after ix1
             if (cline(j:j).eq.' ') ix2=j  
           enddo
           iarg=0
           if (index(cline(ix1:ix2),'ZPOS').ne.0) iarg=1
           if (index(cline(ix1:ix2),'TPOS').ne.0) iarg=-1
           if (index(cline(ix1:ix2),'GAMMA0').ne.0) iarg=2
           if (index(cline(ix1:ix2),'DELGAM').ne.0) iarg=3
           if (index(cline(ix1:ix2),'EMITX').ne.0) iarg=4
           if (index(cline(ix1:ix2),'EMITY').ne.0) iarg=5
           if (index(cline(ix1:ix2),'XBEAM').ne.0) iarg=8   ! XBEAM can be also found in RXBEAM and PXBEAM
           if (index(cline(ix1:ix2),'YBEAM').ne.0) iarg=9   ! Thus comparison with XBEAM has to come first
           if (index(cline(ix1:ix2),'RXBEAM').ne.0) iarg=6
           if (index(cline(ix1:ix2),'RYBEAM').ne.0) iarg=7
           if (index(cline(ix1:ix2),'BETAX').ne.0) iarg=-6
           if (index(cline(ix1:ix2),'BETAY').ne.0) iarg=-7
           if (index(cline(ix1:ix2),'PXBEAM').ne.0) iarg=10
           if (index(cline(ix1:ix2),'PYBEAM').ne.0) iarg=11
           if (index(cline(ix1:ix2),'XPRIME').ne.0) iarg=-10
           if (index(cline(ix1:ix2),'YPRIME').ne.0) iarg=-11
           if (index(cline(ix1:ix2),'ALPHAX').ne.0) iarg=12
           if (index(cline(ix1:ix2),'ALPHAY').ne.0) iarg=13
           if (index(cline(ix1:ix2),'CURPEAK').ne.0) iarg=14
           if (index(cline(ix1:ix2),'ELOSS').ne.0) iarg=15
c
           if (iarg.eq.0) then
              do j=1,15
                 ipar(j)=j
              enddo   
              ncol=15
              j=printerr(errinwarn,
     c              'Unrecognized information line in BEAMFILE')
              return
           else
              ncol=ncol+1 
              ipar(ncol)=iarg
              if (abs(iarg).eq.1) haszpos=1
              cline=cline(ix2+1:255)
              if (ncol.lt.15) goto 1
           endif
         endif
         if (haszpos.lt.1) then
            do j=1,15
               ipar(j)=j
            enddo   
            ncol=15
            j=printerr(errinwarn,
     c            'ZPOS/TPOS column not specified in BEAMFILE')
            return
         endif
         return
      endif
      i=printerr(errinwarn,'Unrecognized information line in BEAMFILE')
      return
      end


      subroutine readslice(nget,x,px,y,py,g,tmin,tmax)
c     =================================================================
c     read slice [tmin,tmax] of particle from distribution file
c     -----------------------------------------------------------------
c
      include 'genesis.def'
      include 'time.cmn'
      include 'io.cmn'

      character*255 line,cerr
      integer nget,n0,i,ix,ip
      real*8 x(*),px(*),y(*),py(*),g(*)
      real*8 tx,tpx,ty,tpy,tt,tg
      real*8 tmin,tmax,values(10)
c
      nget=0
c
      if (keepdist.ne.0) then
         do ip=1,ndist        
           if ((distt(ip).ge.tmin).and.(distt(ip).le.tmax)) then !in slice
             nget=nget+1
             x(nget) =distx(ip)                        !add to raw distribution
             px(nget)=distpx(ip)
             y(nget) =disty(ip)
             py(nget)=distpy(ip)
             g(nget) =distgam(ip)
           endif   
         enddo
         return
      endif
c
      n0=-1
c
 1    read(ndis,200,err=100,end=50) line
c
c     processing line 
c      
      call touppercase(line)
      call getfirstchar(line,ix)
      if (ix.eq.0) goto 1             !empty line
      if (line(ix:ix).eq.'#') goto 1  !comment line
      if (line(ix:ix).eq.'?') goto 1  !information allready processed
c
      if ((n0.lt.0).and.(distversion.lt.1.0)) then
         i=extractval(line,values,1)
         if (i.lt.0) then
            write(cerr,*) 'DISTFILE has invalid input line: ',line
            i=printerr(errinput,cerr)
            call last
         endif
         n0=nint(values(1))
         goto 1
      endif
c
c     get record-tuple 
c
      i=extractval(line,values,ncoldis)
      if (i.lt.0) then
          write(cerr,*) 'DISTFILE has invalid input line: ',line
          i=printerr(errinput,cerr)
          call last
      endif
      do i=1,ncoldis
         if (icolpar(i).eq.1) tx =values(i)
         if (icolpar(i).eq.2) tpx=values(i)
         if (icolpar(i).eq.3) ty =values(i)
         if (icolpar(i).eq.4) tpy=values(i)
         if (icolpar(i).eq.5) tt =distrev*values(i)
         if (icolpar(i).eq.6) tg =values(i)
      enddo
      if (iconv2t.ne.0 ) tt=-tt/3.e8           !convert from z to t
      if (iconv2g.ne.0 ) tg=dsqrt(tg*tg+1.d0)  !convert from p to gamma
      if (iconv2px.ne.0) tpx=tpx*tg            !convert from x' to px
      if (iconv2py.ne.0) tpy=tpy*tg            !convert from y' to py
c
      if ((tt.ge.tmin).and.(tt.le.tmax)) then !in slice
           nget=nget+1
           x(nget) =tx                        !add to raw distribution
           px(nget)=tpx
           y(nget) =ty
           py(nget)=tpy
           g(nget) =tg
      endif   
      goto 1
c      
 50   rewind(ndis)              !set file pointer back
      return 
c
 100  i=printerr(errread,'DISTFILE')
      call last
      return
c
 200  format(a)
c
      end
c
      function readdistfile(file,nio)
c     ==================================================================
c     open an external file containing the distribution. read the file 
c     geting the parameter range etc.
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'particle.cmn'
      include 'input.cmn'
      include 'time.cmn'
      include 'io.cmn'
c
      character*(*) file
      character*255 cerr,line
      integer   nio,nget,i,ix,ip,niotmp
      real*8 tt,values(10)
c      
      ndistsize=-1
      nget=0
c
c     default settings
c
      iconv2g=1       !needs to convert from p to gamma
      iconv2t=0       !long coordinate is time
      iconv2px=0      !convert from x' to px
      iconv2py=0      !convert from y' to py
      distversion=0.1 !first number is number of particles
      distrev=1.      !normal order of long. position
      ncoldis=6       !6 dimension
      do i=1,10
         icolpar(i)=i ! x,px,y,py,t,gamma,id order
      enddo
c      
      readdistfile=-1
      if (index(file,' ').eq.1) return   !no file selected
c
      ftdist=detectfiletype(file)      ! check for filetype
c
csven some compiler gives an error here (segmentation fault)
c     
      niotmp=opentextfile(file,'old',nio)
      readdistfile=niotmp
      if (niotmp.lt.0) call last
c
 1    read(nio,200,err=100,end=50) line
c
c     processing line 
c      
      call touppercase(line)
      call getfirstchar(line,ix)
      if (ix.eq.0) goto 1             !empty line
      if (line(ix:ix).eq.'#') goto 1  !comment line
      if (line(ix:ix).eq.'?') then    !read information line
         call getdistfileinfo(line)
         goto 1
      endif
c
      if ((ndistsize.lt.0).and.(distversion.lt.1.0)) then
         i=extractval(line,values,1)
         if (i.lt.0) then
            cerr='DISTFILE has invalid input line:'//line
            i=printerr(errinput,cerr)
            call last
         endif
         ndistsize=nint(values(1))
         goto 1
      endif
c
c     get record-tuple 
c
      i=extractval(line,values,ncoldis)
      if (i.lt.0) then
          cerr='distfile has invalid input line:'//line
          i=printerr(errinput,cerr)
          call last
      endif
c
      nget=nget+1
      if (keepdist.ne.0) then    ! save variabls if kept in memory
        if (nget.gt.ndmax) then  ! check for overflow 
          i=printerr(errinput,'DISTFILE size exceeds NDMAX')
          call last
        endif 
        do i=1,ncoldis
           if (icolpar(i).eq.1) distx(nget)  =values(i)
           if (icolpar(i).eq.2) distpx(nget) =values(i)
           if (icolpar(i).eq.3) disty(nget)  =values(i)
           if (icolpar(i).eq.4) distpy(nget) =values(i)
           if (icolpar(i).eq.5) distt(nget)  =distrev*values(i)
           if (icolpar(i).eq.6) distgam(nget)=values(i)
        enddo
      endif

      do i=1,ncoldis
         if (icolpar(i).eq.5) tt=distrev*values(i)    !catch time value
      enddo
      if (iconv2t.ne.0) tt=-tt/3.e8           !convert from z to t
c
      if (nget.eq.1) then
         tdmin=tt
         tdmax=tt
      endif
      if (tt.lt.tdmin) tdmin=tt              !adjust min and max
      if (tt.gt.tdmax) tdmax=tt
      goto 1
c
 50   rewind(nio)               !go back to file beginning
      if (keepdist.ne.0) then
         close(nio)
         ndist=nget
         if (iconv2t.ne.0) then
            do ip=1,nget
              distt(ip)=-distt(ip)/3.e8   !convert from space coordinate
            enddo
         endif
         if (iconv2g.ne.0) then
            do ip=1,nget
              distgam(ip)=dsqrt(distgam(ip)*distgam(ip)+1.d0)  !convert from p to gamma
            enddo
         endif
         if (iconv2px.ne.0) then
            do ip=1,nget
              distpx(ip)=distpx(ip)*distgam(ip) ! convert from x' to px
            enddo
         endif
         if (iconv2py.ne.0) then
            do ip=1,nget
              distpy(ip)=distpy(ip)*distgam(ip) ! convert from y' to py
            enddo
         endif
      endif
c
c     set time window
c
      if (nslice.le.0) then
         nslice=int((tdmax-tdmin)*3d8/xlamds/zsep)
         ntail=0
      endif
c  
      if ((ndistsize.ge.0).and.(nget.ne.ndistsize)) then
         i=printerr(errinwarn,'DISTFILE has fewer lines than defined')
      endif
c
      if (ndcut.le.0) ndcut=nget*nharm/npart    !self optimizing
      if (ndcut.le.0) ndcut=1
c
      if (charge.le.0) then
         i=printerr(errinput,'CHARGE for DISTFILE is not defined')
         call last
      endif
c
      delcharge=charge/dble(nget)
      dtd=(tdmax-tdmin)/dble(ndcut)
c
      return
c
 100  readdistfile=printerr(errread,file)
      call last
      return
c
 200  format(a)
c
      end
c

      subroutine getdistfileinfo(line)
c     =================================================================
c     extract information from distfile
c     -----------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
      include 'io.cmn'
c
      character*(*) line
      character*255 cline
      integer n,i,idx,ix1,ix2,ncount,narg,iarg,j,ierr
      real*8  val
c
      narg=0          ! some compile initialize it to unity.
c
      n=len(line)
c      call getfirstchar(line,idx) ! get first character should be identical to index !!
c
c     version number
c  
      i=index(line,'VERSION') !check for version number
      if (i.gt.0) then
        ierr=extractnumber(line(i+7:n),val)
        if (ierr.lt.0) then
           i=printerr(errinwarn,
     c               'Unrecognized information line in distfile')
        else
           distversion=val
        endif
        return
      endif 
c
c     order of distributon
c
      i=index(line,'REVERSE')
      if (i.gt.0) then
         distrev=-1.
         return 
      endif   
c
c     beam charge
c
      i=index(line,'CHARGE')
      if (i.gt.0) then
        ierr=extractnumber(line(i+6:n),val)
        if (ierr.lt.0) then
           i=printerr(errinwarn,
     c               'Unrecognized information line in distfile')
        else
           charge=val
        endif
        return
      endif 
c
c     cuts in long. phase space
c
c     disabled - no program specific instruction should be present
c
c
c      i=index(line,'ndcut') 
c      if (i.gt.0) then
c        ierr=extractnumber(line(i+5:n),val)
c        if (ierr.lt.0) then
c           i=printerr(errinwarn,
c     c               'unrecognized information line in distfile')
c        else
c           ndcut=nint(val)
c        endif
c        return
c      endif 
c
c     size of record
c
      i=index(line,'SIZE') 
      if (i.gt.0) then
        ierr=extractnumber(line(i+4:n),val)
        if (ierr.lt.0) then
           i=printerr(errinwarn,
     c               'Unrecognized information line in distfile')
        else
           ndistsize=nint(val)
        endif
        return
      endif 
c
c     get order and dimension
c

      i=index(line,'COLUMNS') !check for colums headers
      if (i.gt.0) then
         do j=1,10
            icolpar(j)=0
         enddo
         ncoldis=0
         ncount=0
         cline=line(i+7:len(line))
 1       call getfirstchar(cline,ix1)
         if (ix1.gt.0) then
           ix2=255             !search backwards
           do j=255,ix1+1,-1   !for first space after ix1
             if (cline(j:j).eq.' ') ix2=j  
           enddo
           iarg=0
           if (index(cline(ix1:ix2),'P').ne.0) iarg=6
           if (index(cline(ix1:ix2),'GAMMA').ne.0) iarg=-6
           if (index(cline(ix1:ix2),'X').ne.0) iarg=1
           if (index(cline(ix1:ix2),'PX').ne.0) iarg=2
           if (index(cline(ix1:ix2),'XPRIME').ne.0) iarg=-2
           if (index(cline(ix1:ix2),'Y').ne.0) iarg=3
           if (index(cline(ix1:ix2),'PY').ne.0) iarg=4
           if (index(cline(ix1:ix2),'YPRIME').ne.0) iarg=-4
           if (index(cline(ix1:ix2),'T').ne.0) iarg=5
           if (index(cline(ix1:ix2),'Z').ne.0) iarg=-5
c
           ncount=ncount+1
           narg=narg+abs(iarg)
           ncoldis=ncoldis+1
           icolpar(ncoldis)=abs(iarg)
           if (iarg.eq.2)  iconv2px=0
           if (iarg.eq.-2) iconv2px=1
           if (iarg.eq.4)  iconv2py=0
           if (iarg.eq.-4) iconv2py=1
           if (iarg.eq.5)  iconv2t=0
           if (iarg.eq.-5) iconv2t=1
           if (iarg.eq.6)  iconv2g=1
           if (iarg.eq.-6) iconv2g=0
           cline=cline(ix2+1:255)
           if (ncount.lt.10) goto 1
         endif

         if (narg.ne.21) then
            j=printerr(errinwarn,
     c            'Not all dimensions defined in DISTFILE')
            call last
         endif
         return
      endif
c
c     unrecognized
c
      i=printerr(errinwarn,'Unrecognized information line in distfile')
      return
      end
c
      subroutine preset
c     ==================================================================
c     sets default values of program inputs.
c     default parameter modelled after the pegasus fel      
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'field.cmn'
c
      integer i
c
c     wiggler parameters:
c
      aw0    = 0.735          !dimensionless wiggler amplitude (rms).
      xkx       = 0.0d0       !weak focusing strength in x-plane.
      xky       = 1.0d0       !weak focusing strength in x-plane.
      wcoefz(1) = 0.0d0       !field taper start location in z.
      wcoefz(2) = 0.0d0       !field taper gradient
      wcoefz(3) = 0.0d0       !field taper model
      delaw  = 0.0d0          !relative spread in aw
      iertyp = 0              !field error distribution type (<0 = correlated)
      iwityp = 0              !wiggler type (0=planar, 1= wiggler)
      awd    = 0.735          !virtual wiggler field for drift space
      iseed  = -1             !initial seed for wiggler error generation
      fbess0 = 0.0d0          !beam-radiation coupling
      xlamd  = 2.05d-2        !wiggler period  (m)
      awx    = 0.			  ! max offset in x for undulator misalignment
      awy    = 0.			  ! max offset in y for undulator misalignment
      phaseshift = 0          ! phase shift applied per drift
      iautophase = 0          ! flag to enable autophasing
c
c     electron beam parameters:
c
      npart  = 8192           !number of simulation particles.
      gamma0 = 35.2d0         !electron beam lorentz factor (energy)
      delgam = 5.d-3          !rms energy (gamma) spread 
      rxbeam = 112.1d-6       !rms beam size in x-plane 
      rybeam = 112.1d-6       !rms beam size in y-plane 
      alphax= 0d0             !twiss alpha parameter in x
      alphay= 0d0             !twiss alpha parameter in y
      emitx  = 2.0d-6         !normalized emittance x-plane (pi m-rad)
      emity  = 2.0d-6         !normalized emittance y-plane (pi m-rad)
      xbeam  = 0.d0           !center in x (m)
      ybeam  = 0.d0           !center in y (m)
      pxbeam  = 0.d0          !center in px 
      pybeam  = 0.d0          !center in py
      cuttail = -1.           !no collimation transverse tail
      curpeak=2.5d2           !peak current
      conditx = 0.d0          !conditioning in x plane (1/m)
      condity = 0.d0          !conditioning in y plane (1/m)
      bunch = 0.d0            !prebunching, fraction
      bunchphase = 0.d0       !phase for prebunching
      emod = 0.d0             !energy modulation (in gamma)
      emodphase = 0.d0        !phase for energy modulation      
c
c     radiation:
c
      xlamds = 12.852d-6      !output radiation wavelength
      prad0  = 1.00d01        !input power
      pradh0 = 0.00d0         !input power of higher harmonics.
      zrayl  = .500d0         !rayleigh range (of radiation)
      zwaist = 0.0d0          !z location of (radiation) waist.
      radphase=0			  ! although not an input parameter, here is the best place to initialize it.
c
c     numerical control parameters:
c
      ildgam = 5              !energy loading parameter.
      ildpsi = 7              !phase loading parameter.
      ildx   = 1              !x-plane loading parameter.
      ildy   = 2              !y-plane loading parameter.
      ildpx  = 3              !x momentum loading parameter.
      ildpy  = 4              !y momentum loading parameter.
      itgaus = 1              !gaussian (<>0) or uniform (=0) loading
      nbins  = 4              !# of bins in the phase coordinate
      igamgaus = 1            !gaussian (<>0) or uniform (=0) enegy loading    
      inverfc  = 0            !<>0 uses inverse error function to load Gauss  
      ione4one = 0            !<>0 fills slice with one macro particle for one electron, using random number generator
c
c     mesh discretization:
c
      ncar   = 151            !mesh points in one dimension (xy-grid).
      lbc    = 0              !boundary condition (0=diriqlet,<>0 neumann)
      rmax0  = 9.d0           !maximum edge of grid.
      nscr   = 0              !# radial modes for space charge
      nscz   = 0              !# longitudinal modes for space charge 
      nptr   = 40             !radial grid points for space charge
      dgrid  = 0.d0           !grid size(-dgrid to dgrid) if dgrid > 0
      rmax0sc= 0              !if <0 the grid for space charge calculation is fixed, defines the total gridsize  
      iscrkup= 0              !if <> 0 then space charge is calculated at each Runge-Lutta integratio step.
c
c     integration control parameter:
c
      nwig =  98              !number of undulator periods per module
      zsep =  1.              !seperation of slices in units of xlamds
      delz =  1.0             !integration step in units of xlamd
      nsec = 1                !number of sections    
      iorb = 0                !orbit correction flag (<>0 -> use term).
      zstop=-1.               !stop simulation @ z=zstop 
      magin=0                 !read magnetic field description if magin <>0
      magout=0                !write magnetic field description if magout <>0, stop for < 0
      version=0.1             !assume oldest version
c
c     scan control parameter
c
      iscan=0                 !>0 -> iscanth parameter selected
      nscan=3                 !number of scans  
      svar=0.01               !rel. variation [-sval,sval]                
      scan=' '                !scan defined by name
c
c     output control parameters:
c
      iphsty = 1              !history - steps in z 
      ipradi = 0              !radiation field - steps in z
      ippart = 0              !particles - steps in z
      ishsty = 1              !history - steps in t
      isradi = 0              !radiation field - steps in t
      ispart = 0              !particles - steps in t
      do i=1,11
         lout(i)=1            !flags for output
      enddo
      lout(6)=0               !disable diffraction calculation
      do i=12,14+1*nhmax
         lout(i)=0 
      enddo
      iotail=0                !<>0 => output include also slippage
      idump=0                 !<>0 => dump complete radiation field.
      nharm=1                 !# or harmonics in the bunching factor
      iallharm=0              !<>0 => all higher harmonics are calculated up to nharm 
      iharmsc=0               !<>0 => include effects on electron motion
      idmpfld=0               !<>0 => dump radiation field
      idmppar=0               !<>0 => dump particle distribution, with >1 on harmonics
      ilog=0                  !<>0 => terminal output written to file
      ffspec=0                !>0 => total power in near field
      						  !<0 => on-axis intensity in far field
      						  !=0 => on-axis intensity in near field
c
c     file names
c   
      beamfile=' '            !beam description fiel
      fieldfile=' '           !input radiation field
      maginfile=' '           !input magnetic field
      magoutfile=' '          !output magnetic field
      outputfile='template.out'          !output file
      partfile=' '            !input particle file
      distfile=' '            !input distribution file
      radfile=' '             !input radiation file
      filetype='ORIGINAL'     !filetype for output files (sdds,xml)
c
c     focussing:
c
      quadf = 1.23d0          !quad focus strength
      quadd = 0.00d0          !quad defocus strength
      qfdx  = 0.0             !quadrupole offset in x
      qfdy  = 0.0             !quadrupole offset in y
      fl    = 98.             !focus section length
      dl    = 0.              !defocus section length
      drl   = 0.              !drift length
      f1st  = 0.              !start fodo at this point 
      solen = 0.              !strength of solenoid field
      sl    = 0.              !solenoid length
c
c     time dependency parameters:
c
      curlen=1.d-3            !rms bunch length in m (<0 -> uniform beam)
      ntail=-253              !starting slice in beam relative to current peak
      nslice=408              !#slices
      itdp=0                  !<>0 => time dependent code
      shotnoise=1.d0          !scaling of the shotnoise meanvalue
      iall=0                  !<>0 => load phasespace with same loading
      ipseed=-1               !seeding of the random numbers for shotnoise
      ndcut=-2                !=<0 self optimized binning of ext. dist.
      isntyp=0                !=0 -> fawley algorithm <>0 -> Penman algorithm
c
c     extensions
c
      isravg=0                !<>0 enables energy loss by incorerent radiation
      isrsig=0                !<>0 enables growth of energy spread by inc. sr.
      eloss=0.0               !energy loss per meter
      convharm=1              !the harmonic to convert
      multconv=0              !<>0 imported + converted slice is used multiple times
      ibfield=0.0			  !field strength of magnetic chicane
      imagl=0.0				  !length of bending magnet of chicane
      idril=0.0               !length of drift between bending magnets
      igamref=0.0             ! length of reference energy of compressor
      alignradf=0			  !<>0 imported radfile is aligned to electron beam
      offsetradf=0            ! if aligned, number of slices to skip
c
c    transfermatrix 
c
      trama=0                 !<>0 allows to transform 6D phase space
      itram11=1.0d0           ! transfer matrix set equal to identity matrix  
      itram12=0.0d0
      itram13=0.0d0
      itram14=0.0d0
      itram15=0.0d0
      itram16=0.0d0
      itram21=0.0d0
      itram22=1.0d0
      itram23=0.0d0
      itram24=0.0d0
      itram25=0.0d0
      itram26=0.0d0
      itram31=0.0d0
      itram32=0.0d0
      itram33=1.0d0
      itram34=0.0d0
      itram35=0.0d0
      itram36=0.0d0
      itram41=0.0d0
      itram42=0.0d0
      itram43=0.0d0
      itram44=1.0d0
      itram45=0.0d0
      itram46=0.0d0
      itram51=0.0d0
      itram52=0.0d0
      itram53=0.0d0
      itram54=0.0d0
      itram55=1.0d0
      itram56=0.0d0
      itram61=0.0d0
      itram62=0.0d0
      itram63=0.0d0
      itram64=0.0d0
      itram65=0.0d0
      itram66=1.0d0
c 
      return
      end     !preset
c
c
c     
c
      subroutine readradfile(file)
c     =============================================================
c     read the file for external description of the radiation beam
c     -------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'time.cmn'
      include 'io.cmn'
c
      integer nin,i,ncol,ipar(5),ix,idata,j,ft,itmp
      character*(*) file
      character*50 cerr
      character*511 line
      real*8  ver,values(5),tmin,tmax,reverse,zoffset
c
      itmp=0
      nraddata=-1           
      if (index(file,' ').eq.1) return
c
      if ((iscan.gt.0).and.(iscan.lt.25)) then
          i=printerr(errscanex,file)
          return
      endif    
c
c     read file
c
      ft=detectfiletype(file)        ! check for filetype
c
      nin=opentextfile(file,'old',8)
      if (nin.lt.0) call last ! stop program on error
c
      nraddata=-1            !# of rows not defined
      idata=0             !# of rows read
      ncol =5             !# of elements per line
      reverse=1.0         !tail for ZPOS and head for TPOS comes first in file
      zoffset=0.          !offset of shifting the radiation profile
      ver=0.1
      do i=1,ncol
         ipar(i)=i        !basic order of input
      enddo
c
 1    read(nin,100,err=20,end=50) line
c
c     processing line
c     
      call touppercase(line)
      call getfirstchar(line,ix)
c
      if (ix.eq.0) goto 1                     !empty line
      if (line(ix:ix).eq.'#') goto 1          !no comment used
      if (line(ix:ix).eq.'?') then
        call getradfileinfo(line,ipar,ncol,nraddata,ver,reverse,zoffset)  !check for add. info
         goto 1
      endif
c
      if ((nraddata.lt.0).and.(ver.lt.1.0)) then !old version
         i=extractval(line,values,1)
         if (i.lt.0) then
            write(cerr,*) 'Line number of RADFILE cannot be determined'
            i=printerr(errinput,cerr)
         endif
         nraddata=nint(values(1))
         goto 1
      endif
c
      i=extractval(line,values,ncol)
      if (i.lt.0) then
        write(cerr,*) 'RADFILE data line ',idata+1,' has bad format'
        i=printerr(errinput,cerr)
        call last
      endif
c
      idata=idata+1
c
c     set default values      
c
      tradpos(idata)=xlamds*zsep*idata    !can we make this the default?
      tzrayl(idata)=zrayl
      tzwaist(idata)=zwaist
      tprad0(idata)=prad0
      tradphase(idata)=0.			! default no detuning or chirp.
c
c     write over with input data
c
      do j=1,ncol
         if (ipar(j).eq.1 ) tradpos(idata)    = reverse*values(j)
         if (ipar(j).eq.-1) tradpos(idata)    =-reverse*values(j)*3e8  ! time input
         if (ipar(j).eq.2 ) tprad0(idata)   = values(j)
         if (ipar(j).eq.3 ) tzrayl(idata)   = values(j)
         if (ipar(j).eq.4 ) tzwaist(idata)  = values(j)
         if (ipar(j).eq.5 ) tradphase(idata)  = values(j)
      enddo 
c
c     check for unphysical parameters
c
      if (tprad0(idata).lt.0) then
         itmp=printerr(errinput,'Radiation power negative in RADFILE')  !abort
      endif 
c
      if (tzrayl(idata).lt.0) then
         itmp=printerr(errinput,'ZRAYL negative in RADFILE')  !abort
      endif 
c
      if (idata.eq.1) then
         tmin=tradpos(idata)
         tmax=tradpos(idata)
      else
         if (tradpos(idata).gt.tmax) tmax=tradpos(idata)
         if (tradpos(idata).lt.tmin) tmin=tradpos(idata)
      endif
c
      goto 1
c
 50   close(nin)
c 
      if ((nraddata.ge.0).and.(idata.ne.nraddata)) then
         i=printerr(errinwarn,'RADFILE has fewer lines than defined')
      endif
      nraddata=idata
      if (idata.lt.2) then
       i=printerr(errinput,'RADFILE contains less than 2 valid lines')
       call last
      endif
      if (itmp.ne.0) then
       call last
      endif
c
      if (ver.ge.1.0) then
        do i=1,nraddata
          tradpos(i)=tradpos(i)-tmin   !set time window to zero
        enddo
      endif
c
      do i=1,nraddata
          tradpos(i)=tradpos(i)+zoffset   !set time window to zero
      enddo


c
      if (nslice.le.0) then
         nslice=int((tmax-tmin)/xlamds/zsep)
         if (ver.ge.1.0) then
           ntail=int(zoffset/xlamds/zsep)
         else
           ntail=int((tmin+zoffset)/xlamds/zsep)
         endif
         write(ilog,110) nslice,ntail
      endif
c
      return
c
 20   i=printerr(errread,file)
      close(nin)
      call last
      return
c
c     format statement
c
 100  format(a)
 110  format('Auto-adjustment of time window:',/,
     c       'nslice=',i6,/ 
     c       'ntail =',i6)
c
      end     !readradfile
c 
      subroutine getradfileinfo(line,ipar,ncol,ndata,ver,reverse,
     +                          zoffset)
c     =================================================================
c     extract information from beamfile
c     -----------------------------------------------------------------
c
      include 'genesis.def'
c
      character*(*) line
      character*511 cline
      integer ndata,ipar(*),i,n,ncol,ierr,j,ix1,ix2,haszpos,iarg
      real*8  ver,val,reverse,zoffset
c
c     version number
c
      i=index(line,'VERSION') !check for version number
      n=len(line)
      if (i.gt.0) then
        ierr=extractnumber(line(i+7:n),val)
        if (ierr.lt.0) then
           i=printerr(errinwarn,
     c               'Unrecognized information line in RADFILE')
        else
           ver=val
        endif
        return
      endif 
c
c     reverse order
c
      i=index(line,'REVERSE')
      n=len(line)
      if (i.gt.0) then
         reverse=-1.
         return
      endif
c         
c     line numbers
c
      i=index(line,'SIZE') !check for size argument (aka ndata)
      if (i.gt.0) then
        ierr=extractnumber(line(i+4:n),val)
        if (ierr.lt.0) then
           i=printerr(errinwarn,
     c               'Unrecognized information line in RADFILE')
        else
           ndata=nint(val)
        endif
        return
      endif
c         
c     longitudinal offset
c
      i=index(line,'OFFSET') !check for size argument (aka ndata)
      if (i.gt.0) then
        ierr=extractnumber(line(i+6:n),val)
        if (ierr.lt.0) then
           i=printerr(errinwarn,
     c               'Unrecognized information line in RADFILE')
        else
           zoffset=val
        endif
        return
      endif
c
c     column order
c
      i=index(line,'COLUMNS') !check for colums headers
      if (i.gt.0) then
         do j=1,5
            ipar(j)=0
         enddo
         ncol=0
         cline=line(i+7:n)
         haszpos=0
 1       call getfirstchar(cline,ix1)
         if (ix1.gt.0) then
           ix2=255             !search backwards
           do j=255,ix1+1,-1   !for first space after ix1
             if (cline(j:j).eq.' ') ix2=j  
           enddo
           iarg=0
           if (index(cline(ix1:ix2),'ZPOS').ne.0) iarg=1
           if (index(cline(ix1:ix2),'TPOS').ne.0) iarg=-1
           if (index(cline(ix1:ix2),'PRAD0').ne.0) iarg=2
           if (index(cline(ix1:ix2),'ZRAYL').ne.0) iarg=3
           if (index(cline(ix1:ix2),'ZWAIST').ne.0) iarg=4
           if (index(cline(ix1:ix2),'PHASE').ne.0) iarg=5
c
           if (iarg.eq.0) then
              do j=1,5
                 ipar(j)=j
              enddo   
              ncol=5
              j=printerr(errinwarn,
     c              'Unrecognized information line in RADFILE')
              return
           else
              ncol=ncol+1 
              ipar(ncol)=iarg
              if (abs(iarg).eq.1) haszpos=1
              cline=cline(ix2+1:255)
              if (ncol.lt.5) goto 1
           endif
         endif
         if (haszpos.lt.1) then
            do j=1,5
               ipar(j)=j
            enddo   
            ncol=5
            j=printerr(errinwarn,
     c            'ZPOS/TPOS column not specified in RADFILE')
            return
         endif
         return
      endif
      i=printerr(errinwarn,'Unrecognized information line in RADFILE')
      return
      end
c


::::::::::::::
loadbeam.f
::::::::::::::
      function loadbeam(islice,xkper0,seed0)
c     ===================================================================
c     this routine fills the phase space for one slice of phase space
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
      include 'io.cmn'
c
      real*8 enum,snoise,sn1,sn2,ratio,xkper0,w1
      integer i,ip,mpart,islice,loadbeam,iptmp,seed0,iskip
c
c     initialize particle loss
c
      loadbeam=0
      if (npin.gt.0) then 
        return
      endif
c
      lost=0
      do i=1,npart
         lostid(i)=0
      enddo
c
c     initialize the random number generate for each slice
c     note that for a determined shotnoise the hammersley sequences
c     need to be reset at all.
c
c
      ildpsi=-abs(ildpsi)   ! reinitialize all hammersley sequences
      ipseed=seed0
      w1=ran1(ipseed)
      iskip=mod(abs(seed0),1234)
      do i=1,iskip
        w1=hammv(ildpsi)
        w1=hammv(ildx)
        w1=hammv(ildy)
        w1=hammv(ildpx)
        w1=hammv(ildgam)
        w1=hammv(ildgam+1)
      enddo
c
c     fill phase
c
      mpart=npart/nbins               !particles per bin
c

      if (ione4one.eq.0) then
        do ip=1,mpart
         theta(ip)=hammv(ildpsi)*2.*pi/dble(nbins)-pi  !load in first bin
        end do 
      else
        do ip=1,mpart 
          theta(ip)=ran1(ipseed)*2.*pi-pi        !random load for one-one simulation
        enddo
      endif
c  
      if (ndis.gt.0) then
           call loaddist(mpart,islice)   !load from distribution file
           if (ione4one.ne.0)
              mpart=npart0              ! needs to adjust if one4one is selected for distribution
           endif
      else   
           call loadquiet(mpart)         !internal load (quiet start)
      endif   
c
c     normalized transverse position
c 
      do ip=1,mpart
           xpart(ip)=xpart(ip)*xkper0
           ypart(ip)=ypart(ip)*xkper0
      end do 
c
c     mirror particle in remaining bins
c         
      do i=1,nbins-1
         do ip=1,mpart
          xpart(ip+i*mpart)=xpart(ip)
          ypart(ip+i*mpart)=ypart(ip)
          px(ip+i*mpart)=px(ip)
          py(ip+i*mpart)=py(ip)
          gamma(ip+i*mpart)=gamma(ip)
          theta(ip+i*mpart)=theta(ip)+2.*dble(i)*pi/dble(nbins)
          lostid(ip+i*mpart)=lostid(ip)
         end do 
      end do   
c
c     add shotnoise 
c
      if (xcuren .lt.0.d0) then
             i=printerr(errload,'xcuren <=0 in loadbeam')
             xcuren=0
      else
        if (ione4one.eq.0) then
          if (isntyp.eq.0) then ! call shotnoise algorithm only if beamlets are used
             call shotnoise_fawley
          else   
            call shotnoise_penman
          endif  
        endif
      endif   
c
c     add longitudinal correlations (energy modulation, prebunching)
c
      if ((bunch.ne.0.).or.(emod.ne.0.)) then
         do ip=1,npart
            gamma(ip)=gamma(ip)-emod*sin(theta(ip)-emodphase)
            theta(ip)=theta(ip)-2.*bunch*sin(theta(ip)-bunchphase)
c              bunching is J_1(2.*bunch), approximately = bunch
         end do
      end if
c      
c     calculate init. parallel velocity (needed in first call of track)
c
      do ip=1,npart      
	    btpar(ip)=dsqrt(1.d0-(px(ip)**2+py(ip)**2+1.)/gamma(ip)**2)     !parallel velocity
      enddo
c
      call chk_loss
      return
      end     !loadbeam
c
c
c
      subroutine shotnoise_fawley
c     ==================================================================
c     shotnoise algortihm following fawley
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
      include 'work.cmn'
c
      real*8 enum,snoise,sn1,sn2,ratio,xkper0,phin,an
      real*8 ecorr
      integer i,ip,mpart,islice,j,jj,iharm
c

      if (shotnoise.lt.tiny) return
c      
      mpart=npart/nbins
      enum=xcuren*xlamds*zsep/ce/float(mpart)       !#electron in slice per beamlet
      if (enum.lt.10) enum = 10    ! catch low current error

        do ip=1,npart
           p1(ip)=0.
        enddo   
c       
        do iharm=1,(nbins-1)/2
c
c       adjust shotnoise for imported distribution
c
          ecorr=1.
          if ((convharm.gt.1).and.(iharm*convharm.le.nharm)) then
            ecorr=(float(convharm*convharm)-1.)/float(convharm*convharm)
          endif

          do i=1,mpart
           phin=2.*pi*ran1(ipseed)
           an=sqrt(-log(ran1(ipseed))*ecorr/enum)*2./float(iharm)
           do j=1,nbins
              jj=(j-1)*mpart+i
               p1(jj)=p1(jj)-an*sin(float(iharm)*theta(jj)+phin)  
            enddo
          enddo 
        enddo
c        
        do ip=1,npart
           theta(ip)=theta(ip)+p1(ip)*shotnoise
        enddo      
c                    
      return
      end ! of shotnoise_fawley 
c
      subroutine shotnoise_penman
c     ==================================================================
c     shotnoise algorithm following Penman
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
c
      real*8 enum,snoise,sn1,sn2,ratio,xkper0
      integer i,ip,mpart,islice
c
      if (shotnoise.lt.tiny) return
c
      enum=xcuren*xlamds*zsep/ce                           !#electron in slice
      if (enum.lt.10) enum = 10            !catch low current error
      ratio=float(npart)/enum
      snoise=sqrt(3.d0*float(npart)/enum) !shot noise parameter     
c
c     for npart ~ enum the approximation is not precise enough
c      
      if (ratio.gt.0.02) then
         sn1=snoise
         sn2=pi*0.5
 1       snoise=(sn1+sn2)*0.5
         ratio=sin(snoise)**2/snoise/snoise-1.+float(npart)/enum
         if (ratio.lt.0) then
            sn2=snoise
         else
            sn1=snoise
         endif
         if ((sn2-sn1).gt.0.002) goto 1 
      endif
c
        do ip=1,npart
          theta(ip)=theta(ip)+snoise*(1.d0-2.d0*ran1(ipseed))
        end do
c
      return 
      end ! of shotnoise_penman
c             
      subroutine loadquiet(mpart)
c     ==================================================================
c     do quiet loading of transverse phase space
c     -------------------------------------------------------------------
c
      include 'genesis.def'
      include 'particle.cmn'
      include 'input.cmn'
c
      integer mpart,ip
      real*8  xy,x,xx,y,yy,fac,xd,yd,pxd,pyd,xpd,ypd
      real*8  betaxinv,betayinv,r2p,r2
      real*8  ampl_x,ampl_y,dierfc      
c
c     fill energy with standard diviation 1
c
      if (igamgaus.ne.0) then    ! gauss distribution
        if (inverfc.eq.0) then   ! Box-Mueller method
         if (ione4one.eq.0) then ! beamlet loading
           do ip=1,mpart
             gamma(ip)=gasham(ildgam)     ! gauss distribution hammersley
            end do
          else
           do ip=1,mpart
             gamma(ip)=gasran(ipseed)     ! gauss distribution random number (one for one)
            end do
          endif
        else
          if (ione4one.eq.0) then
           do ip=1,mpart
             gamma(ip)=dierfc(hammv(ildgam)*2.)  ! inverse error function
           end do
          else
           do ip=1,mpart
             gamma(ip)=dierfc(ran1(ipseed)*2.)   ! inverse error function (one for one)
           end do
          endif
        endif
      else
        if (ione4one.eq.0) then
          do ip=1,mpart
            gamma(ip)=hammv(ildgam)*2.0d0-1.0d0 ! uniform distribution
          end do      
        else
            gamma(ip)=ran1(ipseed)*2.0d0-1.0d0 ! uniform distribution           
        endif
      endif
c
      if (ione4one.eq.0) then
        mpart=mpart/2     !only half particles per one bin, others symmetric!
      endif               ! disabled if one for one simulation is chosen
c
c     fill x,y,px,py parabolic between [-1,1]
c
      ip=0
 10   continue
      ip=ip+1
 20   continue
      if (ione4one.eq.0) then
        xpart(ip) = hammv(ildx )*2.0d0-1.0d0
        ypart(ip) = hammv(ildy )*2.0d0-1.0d0
        px(ip)    = hammv(ildpx)*2.0d0-1.0d0
        py(ip)    = hammv(ildpy)*2.0d0-1.0d0
      else
        xpart(ip) = ran1(ipseed)*2.0d0-1.0d0
        ypart(ip) = ran1(ipseed)*2.0d0-1.0d0
        px(ip)    = ran1(ipseed)*2.0d0-1.0d0
        py(ip)    = ran1(ipseed)*2.0d0-1.0d0
      endif
cigor correction on 13.03.08 (11 is an improved Gaussian)
csven note: the new Gaussian quiet start algorithm is now enabled
c     with the new input parameter: inverfc <>0

      if (inverfc.eq.0) then
       r2 = xpart(ip)**2+ ypart(ip)**2
       if(r2.ge.1.)goto 20
       r2p=px(ip)**2+py(ip)**2+r2
       if(r2p.ge.1.)goto 20
       if(ip.lt.mpart)goto 10
      end if
       
      if(ip.lt.mpart)goto 10
c
c     enforce profile
c     
      if (inverfc.eq.0) then
        do ip=1,mpart                              
          r2=xpart(ip)**2+ypart(ip)**2+px(ip)**2+py(ip)**2
          if(r2.gt.tiny) then
            fac=1.0d0                                       !parabolic as default
            if(itgaus.eq.1)fac=dsqrt(-1.d0*dlog(1.d0-r2)/r2) !gaussian
            if(itgaus.eq.2)fac=1.d0/dsqrt(r2)                !step
            xpart(ip)=xpart(ip)*fac
            ypart(ip)=ypart(ip)*fac
            px(ip)=px(ip)*fac
            py(ip)=py(ip)*fac
          end if
        end do
      else !gaussian
	 do ip=1,mpart   
	    xpart(ip)=dierfc(1.0-xpart(ip))
            ypart(ip)=dierfc(1.0-ypart(ip))
            px(ip)=dierfc(1.0-px(ip))
            py(ip)=dierfc(1.0-py(ip))
          end do
      end if
cigor end of the correction on 13.03.08 (11 is an improved Gaussian)
cigor  old version 
c      r2 = xpart(ip)**2+ ypart(ip)**2
c      if(r2.ge.1.)goto 20
c      r2p=px(ip)**2+py(ip)**2+r2
c      if(r2p.ge.1.)goto 20
c      if(ip.lt.mpart)goto 10
c
c     enforce profile
c
c       do ip=1,mpart                              
c         r2=xpart(ip)**2+ypart(ip)**2+px(ip)**2+py(ip)**2
c         if(r2.gt.tiny) then
c            fac=1.0d0                                        !parabolic as default
c            if(itgaus.eq.1)fac=dsqrt(-1.d0*dlog(1.d0-r2)/r2) !gaussian
c            if(itgaus.eq.2)fac=1.d0/dsqrt(r2)                !step
c            xpart(ip)=xpart(ip)*fac
c            ypart(ip)=ypart(ip)*fac
c            px(ip)=px(ip)*fac
c            py(ip)=py(ip)*fac
c         end if
c      end do
cigor  end of the old version 

c     correct phasespace loading 
c
      if (ione4one.eq.0) then
        do ip=1,mpart                         !<x>=<y>=0 locally
           xpart(ip+mpart)=-xpart(ip)
           ypart(ip+mpart)=-ypart(ip)
           px(ip+mpart)=-px(ip)
           py(ip+mpart)=-py(ip)
        end do
        mpart=mpart*2
      endif
c
c     remove any correlation between x,px and y,py
c
      call compmom(mpart,x,xx,y,yy,xy,xpart,px)       
      xd=(xy-x*y)/(xx-x*x)
      call compmom(mpart,x,xx,y,yy,xy,ypart,py)       
      yd=(xy-x*y)/(xx-x*x)
      do ip=1,mpart
        px(ip)=px(ip)-xd*xpart(ip)
        py(ip)=py(ip)-yd*ypart(ip)
      enddo      
c
c     normalize distritution -> rms value is 1.
c
      call compmom(mpart,x,xx,y,yy,xy,xpart,ypart)  !compute moments
      xd=1./dsqrt(xx)
      yd=1./dsqrt(yy)
      do ip=1,mpart
         xpart(ip)=xpart(ip)*xd
         ypart(ip)=ypart(ip)*yd
      enddo
c
      call compmom(mpart,x,xx,y,yy,xy,px,py)  !compute moments
      xd=1./dsqrt(xx)
      yd=1./dsqrt(yy)
      do ip=1,mpart
         px(ip)=px(ip)*xd
         py(ip)=py(ip)*yd
      enddo
c
      call cut_tail(mpart)
c
      call compmom(mpart,x,xx,y,yy,xy,gamma,theta)  !compute moments
      xx=xx-x*x
      xd=1./dsqrt(xx)
      if (igamgaus.eq.0) xd=xd/sqrt(3.)
      do ip=1,mpart
         gamma(ip)=(gamma(ip)-x)*xd
      enddo
c
c     scale and shift distribution
c
      ip=0
      if (rxbeam.le.0) ip=printerr(errload,'rxbeam in loadquiet')
      if (rybeam.le.0) ip=printerr(errload,'rybeam in loadquiet')
      if (gamma0.le.1) ip=printerr(errload,'gamma0 in loadquiet')
      if (ip.lt.0) then
          call last
      endif    
c
      betaxinv=emitx/rxbeam**2                !calculation of 1/betax => !sr
      betayinv=emity/rybeam**2                !no sigularity for emit=0  !sr
      pxd=rxbeam*betaxinv                         !rms px at x=0
      pyd=rybeam*betayinv                         !rms py at y=0
      xpd=-alphax*betaxinv                    !slope of phase space ellipse
      ypd=-alphay*betayinv
      do ip=1,mpart
c        define amplitudes, simplest before tilt and rescale is applied
         ampl_x = 0.5*emitx*(px(ip)**2+xpart(ip)**2)
         ampl_y = 0.5*emity*(py(ip)**2+ypart(ip)**2)
         px(ip)=xpd*rxbeam*xpart(ip)+px(ip)*pxd   !scale+shift px
	     py(ip)=ypd*rybeam*ypart(ip)+py(ip)*pyd   !scale+shift py
	     xpart(ip)=xpart(ip)*rxbeam               !scale x to right size
	     ypart(ip)=ypart(ip)*rybeam               !scale y to right size
         gamma(ip)=gamma0+delgam*gamma(ip)
         gamma(ip)=gamma(ip)+conditx*ampl_x+condity*ampl_y
      end do
c
c     shift center in phase space
c
      do ip=1,mpart
         xpart(ip)=(xpart(ip)+xbeam)
         ypart(ip)=(ypart(ip)+ybeam)
         px(ip)=(px(ip)+pxbeam)
         py(ip)=(py(ip)+pybeam)
      end do
 
      return
      end
c
c
      subroutine loaddist(mpart,islice)
c     =================================================================
c     load slice from distribution
c     -----------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
      include 'sim.cmn'
c
      integer mpart,mget,n1,n2,i,islice
      real*8 t0,t1,xa,xs,ya,ys,pxa,pxs,pya,pys,ga,gs
      real*8 tmp1,tmp2,tmp3
c
      t0=tdmax-(ntail+islice-1)*zsep*xlamds/3.d8-0.5*dtd !note sign for t -> z conversion
      t1=t0+dtd
      call readslice(mget,xpart,px,ypart,py,gamma,t0,t1)
      xcuren=delcharge*dble(mget)/dtd    
      if (ione4one.ne.0) then
        npart=xcuren*xlamds*zsep/ce
        npart0=npart
        mpart=npart
      endif
c
      if (mget.lt.5) then
         do i=mget+1,mpart
            xpart(i)=0.d0
            ypart(i)=0.
            px(i)=0.
            py(i)=0.
            gamma(i)=gamma0
         enddo
         return
      endif   
c      
c     adjust and normalize distirbution    
c 
      call compmom(mget,xa,xs,pxa,pxs,tmp3,xpart,px)
      call compmom(mget,ya,ys,pya,pys,tmp3,ypart,py)
      call compmom(mget,ga,gs,tmp1,tmp2,tmp3,gamma,xpart)
c
c     the absolute function should be redundent but sometime a round off
c     error can cause a negative number. the error was pointed out by Gregg Penn 
c
      xs =dsqrt(dabs(xs-xa*xa))      
      pxs=dsqrt(dabs(pxs-pxa*pxa))
      ys =dsqrt(dabs(ys-ya*ya))
      pys=dsqrt(dabs(pys-pya*pya))
      gs =dsqrt(dabs(gs-ga*ga))
      if (xs .lt.tiny) xs =1.d0
      if (pxs.lt.tiny) pxs=1.d0
      if (ys .lt.tiny) ys =1.d0
      if (pys.lt.tiny) pys=1.d0
      if (gs .lt.tiny) gs =1.d0
      call scaledist(xpart,mget,-xa ,1.d0/xs )
      call scaledist(px   ,mget,-pxa,1.d0/pxs)
      call scaledist(ypart,mget,-ya ,1.d0/ys )
      call scaledist(py   ,mget,-pya,1.d0/pys)
      call scaledist(gamma,mget,-ga,1.d0/gs)
c
c     massage proto-distribution
c
      if (mget.ge.mpart) then
c
c         remove particles         
c 
         do i=mpart,mget-1
            n1=int(mget*ran1(ipseed))+1
            call switch(xpart,px,ypart,py,gamma,n1,mget)
            mget=mget-1
         enddo   
      else
c
c        add particle
c
   1     n1=int(dble(mget)*ran1(ipseed))+1
         call neighbor(xpart,px,ypart,py,gamma,n1,n2,mget)
         xpart(mget+1) =xpart(n1) +(xpart(n2) -xpart(n1) )
     +              *(0.5*(ran1(ipseed)+ran1(ipseed)))
         px(mget+1)=px(n1)+(px(n2)-px(n1))
     +              *(0.5*(ran1(ipseed)+ran1(ipseed)))
         ypart(mget+1) =ypart(n1) +(ypart(n2) -ypart(n1) )
     +              *(0.5*(ran1(ipseed)+ran1(ipseed)))
         py(mget+1)=py(n1)+(py(n2)-py(n1))
     +              *(0.5*(ran1(ipseed)+ran1(ipseed)))
         gamma(mget+1) =gamma(n1)+(gamma(n2) -gamma(n1))
     +              *(0.5*(ran1(ipseed)+ran1(ipseed)))
         mget=mget+1
         if (mget.lt.mpart) goto 1
      endif
c
c     scale back
c
      call scaledist(xpart,mpart,xa/xs,xs)
      call scaledist(px   ,mpart,pxa/pxs,pxs)
      call scaledist(ypart,mpart,ya/ys,ys)
      call scaledist(py   ,mpart,pya/pys,pys)
      call scaledist(gamma,mpart,ga/gs,gs)
c
      return
      end
c
c
      subroutine compmom(n,x,x2,y,y2,xy,xa,ya)
c     ==================================================================
c     compute moments
c     ------------------------------------------------------------------
c
      integer n,i
      real*8 xa,ya,x,x2,y,y2,xy,dd
      dimension xa(*),ya(*)                   !>=n
c
      x =0.0d0
      x2=0.0d0
      y =0.0d0
      y2=0.0d0
      xy=0.0d0
      do i=1,n
         x =x +xa(i)
         y =y +ya(i)
         x2=x2+xa(i)*xa(i)
         y2=y2+ya(i)*ya(i)
         xy=xy+xa(i)*ya(i)
      end do
      dd=1.d0/dble(n)							! enforce double precission
      x = x*dd
      y = y*dd
      x2=x2*dd
      y2=y2*dd
      xy=xy*dd
c
      return
      end     !compmom
c
c
      subroutine switch(x,px,y,py,g,n1,n2)
c     =================================================================
c     switch two particles
c     -----------------------------------------------------------------
c
      integer n1,n2
      real*8 x(*),px(*),y(*),py(*),g(*),tmp
c
      tmp=x(n1)
      x(n1)=x(n2)
      x(n2)=tmp
      tmp=px(n1)
      px(n1)=px(n2)
      px(n2)=tmp
      tmp=y(n1)
      y(n1)=y(n2)
      y(n2)=tmp
      tmp=py(n1)
      py(n1)=py(n2)
      py(n2)=tmp
      tmp=g(n1)
      g(n1)=g(n2)
      g(n2)=tmp
      return
      end

      subroutine scaledist(x,n,a,b)
c     ==============================================
c     scales distribution to x -> b*(x+a)
c     ----------------------------------------------
c
      real*8 x(*),a,b
      integer i,n
c
      do i=1,n
         x(i)=b*(x(i)+a)
      enddo
      return
      end
c
      subroutine neighbor(x,px,y,py,g,n1,n2,n)
c     =================================================================
c     search for particle n2 closest to n1
c     -----------------------------------------------------------------
c
      include 'input.cmn'    
c
      integer n1,n2,n,i
      real*8 ran1
      real*8 x(*),px(*),y(*),py(*),g(*),r,rmin
c
      rmin=-1.
      n2=0
      do i=1,n
         r=  (x(n1)-x(i))**2*ran1(ipseed)+(px(n1)-px(i))**2*ran1(ipseed)
         r=r+(y(n1)-y(i))**2*ran1(ipseed)+(py(n1)-py(i))**2*ran1(ipseed)
         r=r+(g(n1)-g(i))**2*ran1(ipseed)
         if (i.ne.n1) then
            if ((rmin.lt.0).or.(r.lt.rmin)) then 
                 n2=i
                 rmin=r
            endif  
         endif
      enddo
      if (n2.eq.0) then
         n2=n1    ! copy himself if only one particle is present
      endif   
      return
      end
c

      subroutine cut_tail(mp)
c     =======================================================
c     collimation of the transverse tails
c     ----------------------------------------------------------
c
      include 'genesis.def'
      include 'particle.cmn'
      include 'input.cmn'
c
      integer i,mp
      real*8 r
c
      if (cuttail.le.0) return      
c
      do i=1,mp
         r=xpart(i)**2+px(i)**2       
         if (r.gt.cuttail) then
             lost=1
             lostid(i)=1
         endif
         r=ypart(i)**2+py(i)**2       
         if (r.gt.cuttail) then
             lost=1
             lostid(i)=1
         endif
      enddo
c
      return
      end
::::::::::::::
loadrad.f
::::::::::::::
      function loadrad(islice)
c     =========================================================
c     fills the array crfield with initial field
c     for start up from noise this should be small
c     ---------------------------------------------------------
c
      include 'genesis.def'
      include 'field.cmn'
      include 'input.cmn'
      include 'work.cmn'
      include 'io.cmn'
      include 'diagnostic.cmn'
      include 'time.cmn'
      include 'sim.cmn'
   
c
      real*8  pradin
      integer ix,irec,islice,ierr,n,loadrad
c
      loadrad=0
c
c     initialize field
c     ---------------------------
      
      do ix=1,ncar*ncar*nhloop
        crfield(ix)=dcmplx(0.,0.)
      enddo
c
      pradoln(1)=prad0          !first halfstep no gain (see diagno)
      do n=2,nhmax
        pradoln(n)=0.d0  !kg
        if (n.eq.nharm) pradoln(n)=pradh0
      end do
c
c     load initial field
c     ------------------------------------------------------------------
c
c
        call gauss_hermite(crfield,prad0,zrayl,
     +  zwaist,xks,radphase,1) !load gauss-hermite mode for all harmonics
        if ((nharm.gt.1).and.(pradh0.gt.0)) then
          call gauss_hermite(crfield,pradh0,zrayl*dble(nharm),
     +    zwaist,xks*dble(nharm),radphase,nharm) !load gauss-hermite mode for higher harmonics
        endif

      return
      end       !of loadrad
c
c
      subroutine gauss_hermite(cfld,power,zr,zw,rks,phase,harm)
c     =======================================================
c     fills array cfld with the fundamental gauss-hermite mode
c     using the total power, wavenumber rks, rayleigh length zr
c     and waist position zw.
c
c     Note - only the fundamental is loaded. harmonics are set to zero
c     --------------------------------------------------------
c
      include 'genesis.def'
      include 'sim.cmn'
      include 'field.cmn'
      include 'input.cmn'
      include 'diagnostic.cmn'

      complex*16 cfld(ncar*ncar*nhmax),cgauss
      real*8     zscal,xcr,ycr,rcr2,power,zr,zw,rks,phase
      integer    iy,ix,idx,n,harm,ioff
      real*8     dump
c
c     check for unphysical parameters
c
      idx=0
      if (zr.le.0) idx=printerr(errload,'zrayl in gauss_hermite')
      if (rks.le.0) idx=printerr(errload,'xks in gauss_hermite')
      if (power.lt.0) idx=printerr(errload,'power in gauss_hermite')
      if (idx.lt.0) call last
c
      ioff=ncar*ncar*(harm-1)             !offset for harmonics
      cgauss=0.5d0*rks/dcmplx(zr,-zw)     !see siegman
      zscal = dsqrt(2.d0*vacimp*power/pi *dble(cgauss))  
     +              *rks/xkper0**2/eev    !?
      dump=0.d0
      do iy=1,ncar
         do ix=1,ncar
             idx=(iy-1)*ncar+ix
             xcr=dxy*float(ix-1)/xkw0-dgrid
             ycr=dxy*float(iy-1)/xkw0-dgrid
             rcr2=xcr*xcr+ycr*ycr 
             cfld(idx+ioff)=
     +           zscal*cdexp(-cgauss*rcr2+dcmplx(0,1)*phase)  !gaussian beam
             dump=dump+dble(cfld(idx+ioff)*conjg(cfld(idx+ioff))) !=sum of |aij|^2 
         end do    !ix
      end do       !iy
      return
      end
c
      subroutine loadslpfld(nslp)
c     =========================================================
c     fills the array crtime with a seeding field for the first 
c     slice.
c     ---------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'field.cmn'
      include 'work.cmn'
      include 'io.cmn'
      include 'timerec.cmn'
      include 'diagnostic.cmn'
c
      integer ix,islp,nslp,ierr,irec,i
c
      if (itdp.eq.0) return

c
c     check for limitation in timerecord                                          
c     ---------------------------------------------------------------             
c                                                                                 
      if (nslice.lt.nslp*(1-iotail))
     c  ierr=printerr(errlargeout,'no output - ntail too small')

      if (nofile.eq.0) then
         if (nslp*ncar*ncar*nhloop.gt.ntmax*nhmax) then
           ierr=printerr(errtime,' ')
           call last
         endif
      endif
c
c     load initial slippage field from file or internal generation 
c     ----------------------------------------------------------------
c


      do islp=1,nslp-1
c
        do ix=1,ncar*ncar*nhloop
          crwork3(ix)=dcmplx(0.,0.)   !initialize the radiation field
        enddo

           call dotimerad(islp+1-nslp)      ! get time-dependence of slippage field behind bunch
           call gauss_hermite(crwork3,prad0,zrayl,zwaist,xks,radphase,1) !load gauss-hermite mode
           if ((nharm.gt.1).and.(pradh0.gt.0)) then
              call gauss_hermite(crwork3,pradh0,zrayl*dble(nharm),
     +                      zwaist,xks*dble(nharm),radphase,nharm) !load gauss-hermite mode for higher harmonics
           endif
           pradoln(1)=prad0
c         endif            
         call pushtimerec(crwork3,ncar,nslp-islp)
      enddo   
      return
      end
c 
c
      function swapfield(islp)
c     ========================================
c     swap current field with then time-record
c     ----------------------------------------
c
      include 'genesis.def'
      include 'mpi.cmn'
      include 'input.cmn'
      include 'field.cmn'
      include 'work.cmn'
c
      integer islp,it
      integer memsize,swapfield
c
      swapfield=0
      memsize=ncar*ncar*nhloop

      do it=1,memsize
          crwork3(it)=crfield(it)
      enddo

      call pulltimerec(crfield,ncar,islp)
      call pushtimerec(crwork3,ncar,islp)
      return
      end ! swapfield
::::::::::::::
magfield.f
::::::::::::::
      subroutine magfield(xkw0,isup)
c     ==================================================================
c     calculates the magnetic structure of the undulator
c     outputs: awz   - wiggler field on axis
c              awdz  - artificial k-parameter for matching of drifts 
c              awerr - kick of momentum due to field errors
c              qx    - focusing strength in x (>0 -> focusing)
c              qy    - focusing strength in y
c
c     working arrays: p1 - readin quadrupole field
c                     k2gg - quad offset in x         
c                     k3gg - quad offset in y         
c                     k2pp - correction in x         
c                     k3pp - correction in x         
c
c     ------------------------------------------------------------------
c
      include  'genesis.def'
      include  'input.cmn'
      include  'magnet.cmn'
      include  'mpi.cmn'
c
      integer nfl,ndl,ndrl,nfodol,n1st,nlat,i1,i2,i,iskip
      integer imz(11),nwigz,iserr,nsl,isup,itmp,nsecl
      real*8 norm,rn,rnx,rny,rold,xkw0,atmp
      real*8 corx(nzmax),cory(nzmax)
c
c=======================================================================
c set default version number for external magnetic file.
c
      magversion = 0.1        ! version of magnetic file
      unitlength = 0          ! unit length in magfile header
c
c=======================================================================
c
c     clear arrays
c
      do i=1,11
         imz(i)=0
      enddo 
      do i=1,nzmax
         awz(i)=0.
         awdz(i)=0.
         qfld(i)=0.
         solz(i)=0.
         awerx(i)=0.
         awery(i)=0.
         dqfx(i)=0.
         dqfy(i)=0.
         corx(i)=0.
         cory(i)=0.
         awdx(i)=0.
         awdy(i)=0.
         awslip(i)=0.
         awphase(i)=0;
      enddo   
c
c     read external file
c
      if (magin.ne.0) call magread(corx,cory,imz,isup)
c
c     estimate length of the undulator
c
      nstepz=0
      nlat=1
      nfodol=nint((fl+dl+2.*drl)/delz)    !steps of internal focusing lattice
      if (nfodol.le.0) nfodol=1
      nwigz=nint(nwig/delz)               !steps of internal undulator section 
      if (imz(4).gt.0) nfodol=imz(4)      !structure defined in input file 
      if (imz(1).gt.0) then
         nsec=1
         nwigz=imz(1)
         nstepz=imz(1)                    !aw0 in input file determines the total length
      endif
c
      if (nstepz.le.0) then               !length yet not defined
         if (nfodol.ge.nwigz) then
            nlat=1                        !# of lattice per section
         else
            nlat=nwigz/nfodol
            if (mod(nwigz,nfodol).gt.0) nlat=nlat+1
         endif   
         nstepz=nsec*nlat*nfodol
      endif   
      if (zstop.le.0) zstop=nstepz*delz*xlamd
cbart      if (zstop.le.(nstepz*delz*xlamd)) nstepz=zstop/xlamd/delz
      if (zstop.le.(nstepz*delz*xlamd)) nstepz=nint(zstop/xlamd/delz)
      if (nstepz.gt.nzmax) then
         i=printerr(errarrbnd,'undulator field')
         nstepz=nzmax
         zstop=nstepz*delz*xlamd
      endif   
c
      if(magin.ne.0) call chk_maglen(imz,nstepz)     ! check whether input file is long enough
c
c     check for inconsistent input
c 
      itmp=0 
      if (imz(4).le.0) then
        if ((fl/delz-1.*int(fl/delz)).gt.small) then
         itmp=printerr(errinput,'FL not a multiple of DELZ')
        endif   
        if ((dl/delz-1.*int(dl/delz)).gt.small) then
         itmp=printerr(errinput,'DL not a multiple of DELZ')
        endif   
        if ((drl/delz-1.*int(drl/delz)).gt.small) then
         itmp=printerr(errinput,'DRL not a multiple of DELZ')
        endif 
        if ((f1st/delz-1.*int(f1st/delz)).gt.small) then
         itmp=printerr(errinput,'F1ST not a multiple of DELZ')
        endif         
      endif
      if (imz(9).le.0) then
        if ((sl/delz-1.*int(sl/delz)).gt.small) then
         itmp=printerr(errinput,'SL not a multiple of DELZ')
        endif
      endif
      if (itmp.lt.0) call last
c
c     generatic magnetic field
c
      nfl=nint(fl/delz)            
      ndl=nint(dl/delz)
      ndrl=nint(drl/delz)
      n1st=nint(f1st/delz)+1      
      nsl=nint(sl/delz)      
      if (imz(9).gt.0) nsl=imz(9)
c
c     check for extreme long fodo cells 
c
      nsecl=nfodol*nlat
      if ((nfodol.gt.(2*nwigz)).and.(nfl.eq.ndl)) then ! if fulfilled nlat must be 1
         nsecl=nsecl/2   ! nsecl is even because fodo cell is symmetric 
         nstepz=nstepz/2 ! the length is calculated above but must corrected here.
      endif
c
      do i1=1,nsec
         rnx=awx*(2.d0*ran1(iseed)-1.d0)   !module offset in x
         rny=awy*(2.d0*ran1(iseed)-1.d0)   !module offset in y
         do i2=1,nsecl
            i=i2+(i1-1)*nsecl
            if (i.le.nstepz) then               !check for array boundary
c
c   if field not externally defined or if no taper defined
c
              if (imz(1).le.0) then   !main undulator field not defined yet
                 if (i2.le.nwigz) then
                    awz(i)=aw0
                    if (imz(10).le.0) awdx(i)=rnx ! offset in x
                    if (imz(11).le.0) awdy(i)=rny ! offset in y
                 endif
c
csven      undulator offset are only generated when the main undulator
csven      is NOT defined in the external file. This is in difference to
csven      quadrupole offset, where errors can be added later. Reason is that
csven      genesis cannot distinguish modules from taper or errors!
csven      hopefully the C++ version of genesis might solve this problem, because
csven      magnetic elements are used in linked lists, thus distingishable!
c
csven      Although accepted by Genesis, defining offsets in the external files
csven      while the main undulator is generated internally is quite illogical!!
c                    
              endif
c
              if (imz(2).le.0) then             !drif section 
                if (awz(i).lt.tiny) awdz(i)=awd
              endif
c
              if (n1st.gt.nfodol) n1st=1        !check for overflow of counter
              if (imz(4).le.0) then             !quadrupole field 
                 if (n1st.le.nfl) qfld(i)=quadf     
                 if ((n1st.gt.(nfl+ndrl)).and.
     c               (n1st.le.(nfl+ndrl+ndl))) qfld(i)=quadd
              endif 
              n1st=n1st+1
c
              if (imz(9).le.0) then             !solenoid field
                  if (i2.le.nsl) solz(i)=solen 
              endif                            
            endif  
         enddo   
      enddo
c
c     field taper: apply to existing lattice of awz(i) - either defined externally or aw0
c
      do i = 1, nstepz
         atmp=awz(i)
         awz(i)=faw0(i,wcoefz,delz,xlamd,atmp,nstepz)
      enddo
c
c
c     field errors: skip this part if iertyp=0 or if delaw=0 (no errors)
c
cbart      if((iertyp.eq.0).or.(delaw.lt.small)) then   ! no/ignore errors in external file
      if((iertyp.ne.0).and.(delaw.gt.small)) then   ! no/ignore errors in external file
         rn=0.
         iserr=0
         iskip=1
         if (iertyp.lt.0) iskip=2                  !correlated error
         do i=1,nstepz,iskip
               if (abs(iertyp).eq.1) then    
                  rn=delaw*(2.d0*ran1(iseed)-1.d0)*dsqrt(3.d0) !uniform error distribution
               else
                  rn=delaw*gasran(iseed)*dsqrt(2.d0)           !gaussian error distribution 
               endif
            awz(i)=awz(i)*(1.+rn)
         enddo   
         awz(0) = awz(1)
         if(iskip.eq.2) then   ! no/ignore errors in external file
           do i=1,nstepz-2,iskip
              if(awz(i)*awz(i+2).gt.small) then
                  awz(i+1) = (awz(i)+awz(i+2))/2.
                  else
                  if(awz(i+1).gt.small) awz(i+1) = awz(i)
              endif
           enddo   
         endif     !  correlated errors
      endif     ! iertyp = 0 or delaw = 0.
      awz(0) = awz(1)  !0
c
      norm=dsqrt(2.d0)          !normalization for the kick due to field errors
      if (iwityp.ne.0) norm=1. 
cbart      if (imz(2).le.0) then
        do i=1,nstepz
           if ((awz(i-1).gt.tiny).and.(awz(i).gt.tiny)) then
              awerx(i)=awerx(i)+(-1.)**i*(awz(i)-awz(i-1))*norm/pi
           endif
        enddo
cbart      endif  
c
      do i=1,nstepz
         awery(i)=awerx(i)*dble(iwityp) !is nonzero for helical undulators
      enddo   
c
c     scale quadrupole & solenoid field
      do i=1,nstepz
         qfld(i)=qfld(i)*586.0
         solz(i)=solz(i)*586.0
      enddo
c 
c     qfdx and qfdy can both be zero and the loop won't do anything.
c     the only check is, whether quadrupole errors are define in the
c     external input files.
c
      rold=0.
      rnx=0.
      rny=0.
      if ((imz(5).eq.0).and.(imz(6).eq.0)) then
        do i=1,nstepz
           if ((dabs(qfld(i)).gt.tiny).and.(dabs(rold).lt.tiny)) then !begin of new quadrupole
             if(qfdx.gt.small) rnx=qfdx*(2.*ran1(iseed)-1)   !offset
             if(qfdy.gt.small) rny=qfdy*(2.*ran1(iseed)-1)
           endif  
           rold=qfld(i)
           if(dabs(qfld(i)).gt.tiny) then
              dqfx(i)=rnx       !doen't matter whether 
              dqfy(i)=rny
           endif
        enddo   
      endif
c  
c     write file with field description.
c
      if ((magout.ne.0).and.(mpi_id.eq.0)) call magwrite(corx,cory,xkw0)
c
c     combine kicks off both planes
c
      do i=1,nstepz
csven         awerx(i)=awerx(i)+(dqfx(i)*qfld(i)+corx(i))/xkw0 !add kick of quad offset
csven         awery(i)=awery(i)+(dqfy(i)*qfld(i)+cory(i))/xkw0 !to kick of field errors
         awerx(i)=awerx(i)+corx(i)/xkw0 !add kick to field errors
         awery(i)=awery(i)+cory(i)/xkw0 !quadrupole offsets are now treated in track.f
         awdx(i)=awdx(i)*xkw0
         awdy(i)=awdy(i)*xkw0
      enddo
c
c     needed for output before 1st step
c
      qfld(0)=qfld(1)
      dqfx(0)=dqfx(1)
      dqfy(0)=dqfy(1)
      awdx(0)=awdx(1)
      awdy(0)=awdy(1)
c
c     autophasing
c
      call autophasing
c
      return
      end
c
c
      subroutine autophasing
c     =======================================================
c     calculate the phase drifts between undulator modules and apply phase adjustment
c
      include 'genesis.def'
      include 'input.cmn'
      include 'magnet.cmn'
c
      integer isbreak,i,islp,ishift
      real*8 phase,xks,coef
c  
      isbreak=0
      phase=0
      xks=twopi/xlamds
      coef=0.5*xks/gamma0/gamma0*delz*xlamd
c
      do i=1,nstepz  
        awslip(i)=delz                     ! default slippage
        awphase(i)=0.                      ! no phase adjustment
        
        if (awz(i).lt.tiny) then         ! new drift
          isbreak=1
          phase=phase-coef*(1+awdz(i)*awdz(i))+twopi*delz    ! calculate the phase slippage difference
          if (phase.gt.pi) then
             ishift=int((phase+pi)/twopi)
             phase=phase-ishift*twopi
             awslip(i)=awslip(i)-ishift;
c             write(*,*) 'slippage suppressed by ',ishift
          endif
        else
          if (isbreak.eq.1) then        ! beginning of new module
             awphase(i)=-phase
             phase=0
             isbreak=0
          endif
        endif
      enddo
c 
      return
      end
c
c
      function faw0(i,wcoefz,delz,xlamd,aw0,nstepz)
c     ==================================================================
c     the wiggler amplitude profile along the undulator
c     the passed variable is the integration step istepz
c     this routine is called only once at the beginning
c
c     the tapering depends on wcoefz:
c             wcoefz(1): taper start location in z
c             wcoefz(2): gradient of field taper
c             wcoefz(3): the type of taper
c                             =0 -> no taper
c                             =1 -> linear taper
c                             =2 -> quadratic taper
c     ------------------------------------------------------------------
c
      implicit none
c
      real*8 z,taplen,pctap,fac,wcoefz(*),delz,xlamd,aw0,faw0
      integer i,nstepz
c
      z = dble(i)*delz*xlamd-wcoefz(1)   !position relative to taper start
      faw0=aw0
      if ((z.le.0.).or.(wcoefz(3).eq.0.)) return !before taper or no taper at all 
c
c    if external magnetic file includes taper, don't do anything
c
      pctap= wcoefz(2)        !taper gradient
      taplen=dble(nstepz)*delz*xlamd-wcoefz(1)  !taper length
c
c     taper models
c     ------------------------------------------------------------------
c
      if (wcoefz(3).lt.1.1d0)then
         fac=1.d0-pctap*z/taplen           !linear taper
      else
        if (wcoefz(3).lt.2.1d0) then
          fac=1.d0-pctap*z*z/taplen/taplen  !quadratic taper
        else
          fac=1
        endif
      endif
      faw0=fac*faw0  
c
      return
      end     !faw0
c
c
      function faw2(i,x,y)
c     ==================================================================
c     calculation of the square of the off-axis wiggler field at step i
c     the dependency on x and y is given by the wiggler type
c     ------------------------------------------------------------------
c
      include  'genesis.def'
      include  'magnet.cmn'
      include  'input.cmn'
c
      real*8 x,y,xt,yt
      integer i
c
      xt=x-awdx(i)   ! include offset
      yt=y-awdy(i)   ! in x and y
      faw2 = awz(i)*awz(i)*(1.d0+xkx*xt*xt+xky*yt*yt)
c
      return
      end     !faw2
c
c
      subroutine magwrite(corx,cory,xkw0)
c     ===================================================================
c     output of the used magentic field
c     -------------------------------------------------------------------
c
      include 'genesis.def'
      include 'magnet.cmn'
      include 'input.cmn'
c
      real*8 corx(*),cory(*),rold,rcur,xkw0
      integer i,ic,k,nmout,nr
      character*3  cid(11)
c
      if(magin.eq.0) magversion = 1.0 ! write in new format unless spec. otherwise
      cid(1)='AW '
      cid(2)='DP '    !not used in output -> can be recalculated from awx, cx and cy
      cid(3)='QF '
      cid(4)='QX '
      cid(5)='QY '
      cid(6)='AD '
      cid(7)='SL '
      cid(8)='CX '
      cid(9)='CY '
      cid(10)='AX'
      cid(11)='AY'
c
      nmout=opentextfile(magoutfile,'unknown',8)
      if (nmout.lt.0) return

c
c  write header of the file
c
      if(magversion.gt.0.12) then
         write(nmout,50) '# header is included'
         write(nmout,40) '? VERSION=',magversion,' including new format'
         write(nmout,45) '? UNITLENGTH=',xlamd*delz,':unit length'
     +                   //' in header'
      endif
c
      do k=1,11
         i=1
         ic=1
         nr=0
         rold=awz(i)
         if (k.eq.2) rold=0.d0
         if (k.eq.3) rold=qfld(i)/586.0
         if (k.eq.4) rold=dqfx(i)
         if (k.eq.5) rold=dqfy(i)
         if (k.eq.6) rold=awdz(i)
         if (k.eq.7) rold=solz(i)/586.0
         if (k.eq.8) rold=corx(i)
         if (k.eq.9) rold=cory(i)
         if (k.eq.10) rold=awdx(i)
         if (k.eq.11) rold=awdy(i)
 1       i=i+1
         ic=ic+1
         rcur=awz(i)
         if (k.eq.2) rcur= 0.d0
         if (k.eq.3) rcur=qfld(i)/586.
         if (k.eq.4) rcur=dqfx(i)
         if (k.eq.5) rcur=dqfy(i)
         if (k.eq.6) rcur=awdz(i)
         if (k.eq.7) rcur=solz(i)/586.
         if (k.eq.8) rcur=corx(i)
         if (k.eq.9) rcur=cory(i)
         if (k.eq.10) rcur=awdx(i)
         if (k.eq.11) rcur=awdy(i)
         if (i.gt.nstepz) then
cbart            if ((ic.gt.2).and.(k.ne.2)) then 
            if ((ic.ge.2).and.(k.ne.2)) then 
               if(magversion.gt.0.12) then
                  write(nmout,60) cid(k),rold,ic-1,nr
                  nr=0
                  else
                  write(nmout,30) cid(k),rold,delz*xlamd,ic-1
               endif
            endif
            goto 2
         endif
         if ((dabs(rcur-rold).gt.tiny).and.(k.ne.2)) then
            if(magversion.gt.0.12) then
               if(abs(rold).lt.tiny) then
                  nr=ic-1
                  else
                  write(nmout,60) cid(k),rold,ic-1,nr
                  nr=0
               endif
               else
               write(nmout,30) cid(k),rold,delz*xlamd,ic-1
            endif
            rold=rcur
            ic=1
         endif
         goto 1
 2      continue   
      enddo   
c
      close(nmout)
      return
c
c     format statements
c
  30  format(a3,1x,1pe14.4,1x,1pe14.4,1x,i4) 
  40  format(a,1x,1f4.2,1x,a) 
  45  format(a,1x,1f7.5,1x,a) 
  50  format(a) 
  60  format(a3,1x,1pe14.4,1x,i4,1x,i4) 
      end  
  
c
c
c
      subroutine magread(corx,cory,imz,isup)
c     ========================================================================
c     input of the magnetic field.
c     only those parameters are replace which are included in the list
c     format : indicator - strength - length - number
c     inticator: aw - wiggler field
c                ad - phase matching between drift section 
c                dp - kick due to field errors 
c                qf - quadrupole field
c                qx - quadrupole offset in x
c                qy - quadrupole offset in y
c                cx - corrector strength in x
c                cy - corrector strength in y
c                sl - solenoid field
c				 ax - undulator offset in x
c				 ay - undulator offset in y
c
c     note: dp,co qx are combined into awerx. output is only dp

c     --------------------------------------------------------------------------
c
      include 'genesis.def'
      include 'magnet.cmn'
      include 'input.cmn'
c
      character*30 cmagtype(12),cin
      character*255 line
      real*8 r1,r2,corx(*),cory(*)
      real*8 r3,values(4),val
      integer i,nr,imz(11),imzb(11),idum,isup
      integer loop,loopcnt,j,k,ntemp,nmin
      integer nloop,ninfo,nr2
      integer int_version,ncol,ierr,nlen,idx
c
      if(isup.ne.0) then
      if(wcoefz(2).ne.0)
     +      ierr=printerr(errinwarn,'Taper defined in namelist')
      if((iertyp.ne.0).and.(abs(delaw).gt.small))
     +      ierr=printerr(errinwarn,'Wiggler errors'//
     +                   ' defined in namelist')
      if(abs(qfdx).gt.small)
     +      ierr=printerr(errinwarn,'Random quad offset errors in x'//
     +                   ' defined in namelist')
      if(abs(qfdy).gt.small)
     +      ierr=printerr(errinwarn,'Random quad offset errors in y'//
     +                   ' defined in namelist')
      if(abs(awx).gt.small)
     +  ierr=printerr(errinwarn,'Random undulator offset errors in x'//
     +                   ' defined in namelist')
      if(abs(awy).gt.small)
     +  ierr=printerr(errinwarn,'Random undulator offset errors in y'//
     +                   ' defined in namelist')
      endif
c
      cmagtype(1)='undulator field'
      cmagtype(2)='drift section'
      cmagtype(3)='field errors'      ! not used anymore
      cmagtype(4)='quadrupole field'
      cmagtype(5)='quadrupole offset in x'
      cmagtype(6)='quadrupole offset in y'
      cmagtype(7)='orbit correction in x'
      cmagtype(8)='orbit correction in y'
      cmagtype(9)='solenoid field'
      cmagtype(10)='undulator offset in x'
      cmagtype(11)='undulator offset in y'

      unitlength = 0.0  ! unit length has to be checked for new version
c
      nlen=len(line)  ! line size can be easily changed
      loop=0
      loopcnt=0
      int_version=2   ! check if version set to 0.1
      ncol=3          ! default older version to read 3 numbers after the identifier
c
c     open file 
c
      nmin=opentextfile(maginfile,'old',8)
      if (nmin.lt.0) return
c
 1    read(nmin,1000,end=2,err=100) line    ! read line
c   
      call touppercase(line)                !convert to upper case
      call getfirstchar(line,idx)           !get index of first non-space char. 
c
      if (idx.eq.0) goto 1                  !empty line
      if (line(idx:idx).eq.'#') goto 1      !comment line
      if (line(idx:idx).eq.'?') then        !information line
         call getmagfileinfo(line(idx+1:nlen))
         if(magversion.lt.0.11) then
             ncol=3
             int_version=1
         else
             ncol=3                         !read 4 number at version >= 1.0
         endif
         goto 1
      endif
      if (line(idx:idx).eq.'!') then        ! start/end loop structure
         line=line(idx+1:nlen)
         call getfirstchar(line,idx)
         if (idx.eq.0) then   
            i=printerr(errinwarn,'Empty line behind "!": ignored')
            goto 1
         endif
c
c check for start of loop: set loop counter
c
         nloop=index(line,'LOOP')
         if (nloop.eq.0) then
            ierr=printerr(errinwarn,'Undefined command in maginfile')
            goto 1
         endif
         if (nloop.eq.idx) then
            if(loop.eq.1) then ! start next loop before ending previous 
               nloop=printerr(errinwarn, 'Illegal ending of loop') ! forced stop
               close(nmin)
               call last
            endif     
            ierr=extractnumber(line(idx+4:nlen),val)
            if (ierr.lt.0) then
               i=printerr(errinwarn,'Undefined loop argument')
               goto 1
            else
               loopcnt=int(val)
            endif
            if (loopcnt.gt.1) then
               loop=1
               do k=1,11
                  imzb(k)=imz(k)
               enddo 
            endif  
            goto 1
         endif
c
c check for loop ending: reset loopcounter and copy loop
c
         nloop=index(line,'ENDLOOP')
         if((nloop.eq.idx).and.(loop.eq.1)) then        ! a loop is ended
            do j=2,loopcnt   ! copy filed loopcnt-1 times
              do k=1,11 
                 ntemp=imz(k)-imzb(k)
                 if ((imz(1)+ntemp).gt.nzmax) then
                    idum=printerr(errarrbnd,cmagtype(k))
                 else
                   do i=1,ntemp
                     if (k.eq.1) awz(imz(1)+i)=awz(imzb(1)+i)
                     if (k.eq.2) awdz(imz(2)+i)=awdz(imzb(2)+i)
                     if (k.eq.4) qfld(imz(4)+i)=qfld(imzb(4)+i)
                     if (k.eq.5) dqfx(imz(5)+i)=dqfx(imzb(5)+i)
                     if (k.eq.6) dqfy(imz(6)+i)=dqfy(imzb(6)+i)
                     if (k.eq.7) corx(imz(7)+i)=corx(imzb(7)+i)
                     if (k.eq.8) cory(imz(8)+i)=cory(imzb(8)+i)
                     if (k.eq.9) solz(imz(9)+i)=solz(imzb(9)+i)
                     if (k.eq.10) awdx(imz(10)+i)=awdx(imzb(10)+i)
                     if (k.eq.11) awdy(imz(11)+i)=awdy(imzb(11)+i)
                   enddo
                   imz(k) = imz(k)+ntemp
                   imzb(k)=imzb(k)+ntemp
                 endif
              enddo
            end do
            loop=0     !finish the round of copying
            loopcnt=0
            goto 1
         endif
      endif
c
c     process input line
c
      cin=line(idx:idx+1)   !get identifier
      k=-1
      if (cin(1:2).eq.'AW') k=1 !main wiggler field
      if (cin(1:2).eq.'AD') k=2 !art. wiggler field between section
      if (cin(1:2).eq.'QF') k=4 !quadrupole field strength
cbart      if (cin(1:2).eq.'QD') k=5 !quadrupole offset in x
      if (cin(1:2).eq.'QX') k=5 !quadrupole offset in x
      if (cin(1:2).eq.'QY') k=6 !quadrupole offset in y
      if (cin(1:2).eq.'CX') k=7 !correcter strength in x
      if (cin(1:2).eq.'CY') k=8 !corrector strength in y
      if (cin(1:2).eq.'SL') k=9 !solenoid strength
      if (cin(1:2).eq.'AX') k=10 !undulator offset in x
      if (cin(1:2).eq.'AY') k=11 !undulator offset in y
      if (k.lt.0) then
         ierr=printerr(errconv,cin(1:2))
         goto 1
      endif
c      
      line=line(idx+2:nlen)
      call getfirstchar(line,idx) !eliminate spaces in the beginning
      if (idx.gt.0) line=line(idx:nlen) 
      ierr=extractval(line,values,ncol)
      if (ierr.lt.0) then
         ierr=printerr(errconv,line)
         goto 1
      endif
      r1=values(1)              !strength/offset
c
c     filling the arrays
c
      if (magversion.ge.0.12) then
         nr=nint(values(2))         !length in unit length
         nr2=nint(values(3)) !separation to prev. element       
         if((nr.lt.0).or.(nr2.lt.0)) then
            idum=printerr(errinput,'Negative element'
     +            //' length/distance in maginfile')
            call last
         endif
         r2=unitlength              !unit length
         r3=r2*nr2

         nr2 = nint(r3/delz/xlamd)
         if(abs(nr2-r3/delz/xlamd).gt.small) then
            i=printerr(errmagrnd,line) ! different error needed ?????????
         endif 
         if ((imz(k)+nr2).gt.nzmax) then
            idum=printerr(errarrbnd,cmagtype(k))
         else
            imz(k)=imz(k)+nr2
         endif 
         else
         r2=values(2)              !unit length
         nr=nint(values(3))         !length in unit length
         if((nr.lt.0).or.(r2.lt.-small)) then
            idum=printerr(errinput,'negative element'
     +            //' length/distance in maginfile')
            call last
         endif
      endif
c
      r2=r2*nr                !full length of this section
      nr=nint(r2/delz/xlamd)  !# int. steps for this section
      if(abs(nr-r2/delz/xlamd).gt.small) then
        i=printerr(errmagrnd,line) 
      endif 
      if ((imz(k)+nr).gt.nzmax) then
         idum=printerr(errarrbnd,cmagtype(k))
      else
         do i=1,nr
            if (k.eq.1) awz(imz(1)+i)=r1
            if (k.eq.2) awdz(imz(2)+i)=r1
            if (k.eq.4) qfld(imz(4)+i)=r1
            if (k.eq.5) dqfx(imz(5)+i)=r1
            if (k.eq.6) dqfy(imz(6)+i)=r1
            if (k.eq.7) corx(imz(7)+i)=r1
            if (k.eq.8) cory(imz(8)+i)=r1
            if (k.eq.9) solz(imz(9)+i)=r1
            if (k.eq.10) awdx(imz(10)+i)=r1
            if (k.eq.11) awdy(imz(11)+i)=r1
         enddo
         imz(k)=imz(k)+nr
      endif
      goto 1      ! read new line
c
c     final processing + closing files
c
 2    if(int_version.eq.2) magversion = 1.0
      if(loop.eq.1) ninfo=
     c       printerr(errinwarn, '"LOOP" not terminated: no loop') 
      call closefile(nmin)
c
      return 
c
c     error
c
 100  idum=printerr(errread,maginfile)
      goto 1
c
c     format statements
c
 1000 format(a)
c
      end

c
      subroutine chk_maglen(imz,nstepz)
c     ===================================================================
c     checks whether the user supplied file for the description of the
c     magnetic fields is incomplete
c     -------------------------------------------------------------------
c
      include 'genesis.def'
c
      character*30   cmagtype(11)
      integer i,j,imz(11),nstepz
c
      cmagtype(1)=' undulator field'
      cmagtype(2)=' drift section'
      cmagtype(4)=' quadrupole field'
      cmagtype(5)=' quadrupole offset in x'
      cmagtype(6)=' quadrupole offset in y'
      cmagtype(7)=' orbit correction in x'
      cmagtype(8)=' orbit correction in y'
      cmagtype(9)=' solenoid field'
      cmagtype(10)=' undulator offset in x'
      cmagtype(11)=' undulator offset in y'

c
      do i=1,11
         if ((imz(i).gt.1).and.(imz(i).lt.nstepz)) then
            j=printerr(errmagshort,cmagtype(i))
         endif
      enddo
      return
      end ! of chk_maglen
c
c
      subroutine getmagfileinfo(line)
c     =================================================================
c     extract information from beamfile
c     -----------------------------------------------------------------
c
      include 'genesis.def'
      include 'magnet.cmn'
c
      character*(*) line
      integer n,i,idx,ierr
      real*8  val
c
      n=len(line)
      call getfirstchar(line,idx) ! get first character should be identical to index !!
c
c     version number
c
      i=index(line,'VERSION') !check for version number
      if ((i.gt.0).and.(i.eq.idx)) then
        ierr=extractnumber(line(i+7:n),val)
        if (ierr.lt.0) then
           i=printerr(errinwarn,
     c               'Unrecognized information line in maginfile')
        else
           magversion=val
        endif
        return
      endif 
c
c
      i=index(line,'UNITLENGTH') !check for unit length
      if ((i.gt.0).and.(i.eq.idx)) then
        ierr=extractnumber(line(i+7:n),val)
        if (ierr.lt.0) then
           i=printerr(errinwarn,
     c               'Unrecognized information line in maginfile')
        else
           unitlength=val
        endif
        return
      endif 
c
c     unrecognized
c
      i=printerr(errinwarn,'Unrecognized information line in beamfile')
      return
      end
c


::::::::::::::
math.f
::::::::::::::
      real*8 function gasham(j)
c     ==================================================================
c     gaussian hammersley sequence
c     reinitializable
c     ------------------------------------------------------------------
c
      integer j,jmax,icall,iset,jd
      parameter (jmax=26)
      real*8 v1,v2,hammv,r,fac,gset
      dimension iset(jmax),gset(jmax)
      data icall/0/,iset/jmax*0/,gset/jmax*0.d0/
c
      if((icall.eq.0).or.(j.lt.0)) then
	 do jd=1,jmax
	    iset(jd)=0
	 end do
	 icall=1
      end if
      if(iset(j).eq.0) then
 1       v1=hammv(j)*2.d0-1.d0
	 v2=hammv(j+1)*2.d0-1.d0
	 r=v1**2+v2**2
	 if(r.ge.1..or.r.eq.0.)goto 1
	 fac=dsqrt(-2.d0*dlog(1.d0-r)/r)
	 gset(j)=v1*fac
	 gasham =v2*fac
	 iset(j)=1
      else
	 gasham=gset(j)
	 iset(j)=0
      end if
c
      return
      end     !gasham
c
c
c
      real*8 function hammv(j)
c     ==================================================================
c     uniform hammersley sequence
c     reinitializable
c     ------------------------------------------------------------------
c
      real*8 xs,xsi
      integer j,jmax,i,nbase,i1,i2,icall,jd
      parameter (jmax=26)
      dimension nbase(jmax),i(jmax),xs(jmax),xsi(jmax)
      dimension i1(jmax),i2(jmax)
      data nbase/2.,3.,5.,7.,11.,13.,17.,19.,23.,29.,31.,37.,41.,43.,
     1          47.,53.,59.,61.,67.,71.,73.,79.,83.,89.,97.,101./
      data icall/0/
      data i/jmax*0/
c
      if ((icall.eq.0).or.(j.lt.0)) then
	 do jd=1,jmax
	    i(jd)=0
	 end do
	 icall=1
         j=abs(j)
      end if
      xs (j)=0.d0
      xsi(j)=1.0d0
      i(j)= i(j)+1
      i2 (j)= i(j)
 10   xsi(j)=xsi(j)/float(nbase(j))
      i1 (j)= i2(j)/nbase(j)
      xs (j)= xs(j)+(i2(j)-nbase(j)*i1(j))*xsi(j)
      i2 (j)= i1(j)
      if(i2(j).gt.0) goto 10
      hammv=xs(j)
c
      return
      end     !hammv

c
c
c
      real*8 function ran1(idum)
c     ==================================================================
c     random number generator from numerical recipes (p. 272f).
c     ------------------------------------------------------------------
c
      integer idum,im1,im2,imm1,ia1,ia2,iq1,iq2,ir1,ir2,ntab,ndiv
      real*8  am,eps,rnmx
      parameter (im1=2147483563,im2=2147483399,am=1./im1,imm1=im1-1,
     +           ia1=40014,ia2=40692,iq1=53668,iq2=52774,ir1=12211,
     +           ir2=3791,ntab=32,ndiv=1+imm1/ntab,eps=1.2d-40,
     +           rnmx=1.d0-eps)
      integer idum2,j,k,iv(ntab),iy
      save iv,iy,idum2
      data idum2/123456789/,iv/ntab*0/,iy/0/
c
      if (idum.le.0) then
          idum=max(-idum,1)
          idum2=idum
          do j=ntab+8,1,-1
             k=idum/iq1
             idum=ia1*(idum-k*iq1)-k*ir1
             if (idum.lt.0) idum=idum+im1
             if (j.le.ntab) iv(j)=idum
          enddo
          iy=iv(1)
      endif
      k=idum/iq1
      idum=ia1*(idum-k*iq1)-k*ir1
      if (idum.lt.0) idum=idum+im1
      k=idum2/iq2
      idum2=ia2*(idum2-k*iq2)-k*ir2
      if (idum2.lt.0) idum2=idum2+im2
      j=1+iy/ndiv
      iy=iv(j)-idum2
      iv(j)=idum 
      if (iy.lt.1) iy=iy+imm1
      ran1=min(am*iy,rnmx)
      return
      end
c
c
      real*8 function gasran(idum)
c     ==================================================================
c     random number generator from numerical recipes (p. 272f).
c     ------------------------------------------------------------------
c
      integer iset,idum
      real*8 v1,v2,ran1,r,fac,gset
      save gset,iset
c
      if(iset.eq.0) then
 1       v1=ran1(idum)*2.d0-1.d0
	     v2=ran1(idum)*2.d0-1.d0
	     r=v1**2+v2**2
	     if(r.ge.1..or.r.eq.0.)goto 1
	     fac=dsqrt(-2.d0*dlog(1.d0-r)/r)
	     gset=v1*fac
	     gasran =v2*fac
	     iset=1
	  else
	     gasran=gset
	     iset=0
      end if
c
      return
      end
c
c
c
      function bessj0(x)
c     ==================================================================
c     bessel function j0 - numerical rec.
c     ------------------------------------------------------------------
c
      real*8 y,p1,p2,p3,p4,p5,q1,q2,q3,q4,q5,r1,r2,r3,r4,r5,r6,
     *    s1,s2,s3,s4,s5,s6, x, bessj0, ax, z, xx
      data p1,p2,p3,p4,p5/1.d0,-.1098628627d-2,.2734510407d-4,
     *    -.2073370639d-5,.2093887211d-6/, q1,q2,q3,q4,q5/-.1562499995d-
     *1,
     *    .1430488765d-3,-.6911147651d-5,.7621095161d-6,-.934945152d-7/
      data r1,r2,r3,r4,r5,r6/57568490574.d0,-13362590354.d0,651619640.7d
     *0,
     *    -11214424.18d0,77392.33017d0,-184.9052456d0/,
     *    s1,s2,s3,s4,s5,s6/57568490411.d0,1029532985.d0,
     *    9494680.718d0,59272.64853d0,267.8532712d0,1.d0/
      if(abs(x).lt.8.)then
         y=x**2
         bessj0=(r1+y*(r2+y*(r3+y*(r4+y*(r5+y*r6)))))
     *      /(s1+y*(s2+y*(s3+y*(s4+y*(s5+y*s6)))))
         else
         ax=abs(x)
         z=8./ax
         y=z**2
         xx=ax-.785398164
         bessj0=sqrt(.636619772/ax)*(cos(xx)*(p1+y*(p2+y*(p3+y*(p4+y
     *      *p5))))-z*sin(xx)*(q1+y*(q2+y*(q3+y*(q4+y*q5)))))
      endif
c
      return
      end
c
c
c
      function bessj1(x)
c     ==================================================================
c     bessel function j1 - numerical rec.
c     ------------------------------------------------------------------
c
      real*8 y,p1,p2,p3,p4,p5,q1,q2,q3,q4,q5,r1,r2,r3,r4,r5,r6,
     *    s1,s2,s3,s4,s5,s6, x, bessj1, ax, z, xx
      data r1,r2,r3,r4,r5,r6/72362614232.d0,-7895059235.d0,242396853.1d0
     *,
     *    -2972611.439d0,15704.48260d0,-30.16036606d0/,
     *    s1,s2,s3,s4,s5,s6/144725228442.d0,2300535178.d0,
     *    18583304.74d0,99447.43394d0,376.9991397d0,1.d0/
      data p1,p2,p3,p4,p5/1.d0,.183105d-2,-.3516396496d-4,.2457520174d-5
     *,
     *    -.240337019d-6/, q1,q2,q3,q4,q5/.04687499995d0,-.2002690873d-3
     *,
     *    .8449199096d-5,-.88228987d-6,.105787412d-6/
      if(abs(x).lt.8.)then
         y=x**2
         bessj1=x*(r1+y*(r2+y*(r3+y*(r4+y*(r5+y*r6)))))
     *      /(s1+y*(s2+y*(s3+y*(s4+y*(s5+y*s6)))))
         else
         ax=abs(x)
         z=8./ax
         y=z**2
         xx=ax-2.356194491
         bessj1=sqrt(.636619772/ax)*(cos(xx)*(p1+y*(p2+y*(p3+y*(p4+y
     *      *p5))))-z*sin(xx)*(q1+y*(q2+y*(q3+y*(q4+y*q5)))))
     *      *sign(1.d0,x)
      endif
c
      return
      end
c
c
      function bessj(n,x)
c     ==================================================================
c     bessel function of order n - taken from numerical rec.
c     ------------------------------------------------------------------
c
      integer n, IACC
      real*8 bessj, x, BIGNO, BIGNI
      parameter (IACC=40,BIGNO=1.E10, BIGNI=1E-10)
      integer j,jsum,m
      real*8 ax,bj,bjm,bjp,sum,bessj0,bessj1,tox
          
      ax = abs(x)
      if (ax.eq.0) then
        bessj=0
      else if (ax.gt.float(n)) then
        tox = 2./ax
        bjm = bessj0(ax)
        bj  = bessj1(ax)
        do j = 1, n-1
            bjp = j*tox*bj-bjm
            bjm=bj
            bj=bjp
        enddo
        bessj = bj
      else
        tox=2./ax
        m = 2*((n+int(sqrt(float(IACC*n))))/2)
        bessj=0.0
        jsum=0
        sum=0.0
        bjp=0.
        bj=1.
        do j=m,1,-1
            bjm=j*tox*bj-bjp
            bjp=bj
            bj=bjm
            if(abs(bj).gt.BIGNO) then
                bj=bj*BIGNI
                bjp=bjp*BIGNI
                bessj=bessj*BIGNI
                sum=sum*BIGNI
            endif
            if(jsum.ne.0) sum = sum +bj
            jsum = 1-jsum
            if (j.eq.n) bessj=bjp
        enddo      
        sum=2.0*sum-bj
        bessj=bessj/sum
      endif
      
      if(x.lt.0..and.mod(n,2).eq.1) bessj=-bessj
      
      if(n.eq.0) then
        bessj=bessj0(ax)
      endif
      
      if(n.eq.1) then
        bessj= bessj1(ax)
      endif
      
      return
      end  
c
c
      integer function luf(x,table,n)
c     ==================================================================
c     luf is a table lookup function that locates a value x between
c     elements of an increasing table of size n.
c     luf is the value of the index after the table location which
c     x corresponds to.
c     the routine uses a bisection methode (numerical rec.)
c     the array table must be monotonic
c     luf=1 or luf=n+2 is returned to indicate out of range
c     ------------------------------------------------------------------
c
      real*8 x,table(*)
      integer n,jl,ju,jm
c
      jl=0            !lower limit
      ju=n+1          !upper limit
 10   if(ju-jl.gt.1) then
	  jm=(ju+jl)/2    !midpoint
	  if((table(n).gt.table(1)).eqv.(x.gt.table(jm))) then
	    jl=jm
	    else
	    ju=jm
	  endif
	  goto 10
      endif
      luf=jl+1
c
      return
      end     !luf
c
c
c
      subroutine fourn(data,nn,ndim,isign)
c     =================================================================
c     multidimensional fft of complex values (num. rec.)
c     number of elements of data must be a power of 2!
c     nn = number of dimension
c     ndim(nn) = elements per dimension
c     isign = 1 fft, = -1 inverse fft     
c     -----------------------------------------------------------------
c
      integer isign,ndim,nn(ndim)
      real*8 data(*)
      integer i1,i2,i2rev,i3,i3rev,ibit,idim,ifp1,ifp2,ip1,ip2,ip3,k1,
     *k2,n,nprev,nrem,ntot
      real*8 tempi,tempr
      double precision theta,wi,wpi,wpr,wr,wtemp
      ntot=1
      do 11 idim=1,ndim
        ntot=ntot*nn(idim)
11    continue
      nprev=1
      do 18 idim=1,ndim
        n=nn(idim)
        nrem=ntot/(n*nprev)
        ip1=2*nprev
        ip2=ip1*n
        ip3=ip2*nrem
        i2rev=1
        do 14 i2=1,ip2,ip1
          if(i2.lt.i2rev)then
            do 13 i1=i2,i2+ip1-2,2
              do 12 i3=i1,ip3,ip2
                i3rev=i2rev+i3-i2
                tempr=data(i3)
                tempi=data(i3+1)
                data(i3)=data(i3rev)
                data(i3+1)=data(i3rev+1)
                data(i3rev)=tempr
                data(i3rev+1)=tempi
12            continue
13          continue
          endif
          ibit=ip2/2
1         if ((ibit.ge.ip1).and.(i2rev.gt.ibit)) then
            i2rev=i2rev-ibit
            ibit=ibit/2
          goto 1
          endif
          i2rev=i2rev+ibit
14      continue
        ifp1=ip1
2       if(ifp1.lt.ip2)then
          ifp2=2*ifp1
          theta=isign*6.28318530717959d0/(ifp2/ip1)
          wpr=-2.d0*sin(0.5d0*theta)**2
          wpi=sin(theta)
          wr=1.d0
          wi=0.d0
          do 17 i3=1,ifp1,ip1
            do 16 i1=i3,i3+ip1-2,2
              do 15 i2=i1,ip3,ifp2
                k1=i2
                k2=k1+ifp1
                tempr=sngl(wr)*data(k2)-sngl(wi)*data(k2+1)
                tempi=sngl(wr)*data(k2+1)+sngl(wi)*data(k2)
                data(k2)=data(k1)-tempr
                data(k2+1)=data(k1+1)-tempi
                data(k1)=data(k1)+tempr
                data(k1+1)=data(k1+1)+tempi
15            continue
16          continue
            wtemp=wr
            wr=wr*wpr-wi*wpi+wr
            wi=wi*wpr+wtemp*wpi+wi
17        continue
          ifp1=ifp2
        goto 2
        endif
        nprev=n*nprev
18    continue
      return
      end

cigor  added on 13.03.08 (for itgaus=11, an improved Gaussian)
csven  input parameters have been modified. dierfc is evoked with
c      inverfc <> 0 as an input parameter
c
      real*8 function dierfc(y)
c     ==========================================================
c     inverted error function
c     original author:  Takuya OOURA
c     Takuya OOURA, Research Institute for Mathematical Sciences // 
c     Kyoto University, Kyoto 606-01 Japan // 
c     Email : ooura@kurims.kyoto-u.ac.jp (orooura@mmm.t.u-tokyo.ac.jp ). 
c     reference: http://www.kurims.kyoto-u.ac.jp/~ooura/gamerf.html
c
c     function is used for generating gaussian distribution avoiding the
c     joint-propability approach with itgauss=11
c
            
        real*8 y   
        real*8  s, t, u, w, x, z
	z = y
        if (y.gt.1.0)  z = 2.0 - y
        
        w = 0.916461398268964 - dlog(z)
        u = dsqrt(w)
        s = (dlog(u) + 0.488826640273108) / w
        t = 1 / (u + 0.231729200323405)
        x = u * (1 - s * (s * 0.124610454613712 + 0.5)) - 
     +   ((((-0.0728846765585675 * t + 0.269999308670029) * t + 
     +   0.150689047360223) * t + 0.116065025341614) * t + 
     +   0.499999303439796) * t
        t = 3.97886080735226 / (x + 3.97886080735226)
        u = t - 0.5
        s = (((((((((0.00112648096188977922 * u + 
     +   1.05739299623423047e-4) * u - 0.00351287146129100025) * u - 
     +   7.71708358954120939e-4) * u + 0.00685649426074558612) * u + 
     +   0.00339721910367775861) * u - 0.011274916933250487) * u - 
     +   0.0118598117047771104) * u + 0.0142961988697898018) * u + 
     +   0.0346494207789099922) * u + 0.00220995927012179067
        s = ((((((((((((s * u - 0.0743424357241784861) * u - 
     +   0.105872177941595488) * u + 0.0147297938331485121) * u + 
     +   0.316847638520135944) * u + 0.713657635868730364) * u + 
     +   1.05375024970847138) * u + 1.21448730779995237) * u + 
     +   1.16374581931560831) * u + 0.956464974744799006) * u + 
     +   0.686265948274097816) * u + 0.434397492331430115) * u + 
     +   0.244044510593190935) * t - 
     +   z * dexp(x * x - 0.120782237635245222)
         x = x+s * (x * s + 1)
        if (y.gt.1) x = -x
	  dierfc=x
        return 
	end


::::::::::::::
mpi_common.f
::::::::::::::
      subroutine mpisetstatus(size,id)
  
      include 'genesis.def'
      include 'mpi.cmn'
      integer size,id

      mpi_id=id
      mpi_size=size

      return
      end
c


::::::::::::::
output.f
::::::::::::::
      function output(istepz,islice,xkw0)
c     =============================================
c     calls all output function
c     ---------------------------------------------
c
      include 'genesis.def'
      include 'io.cmn'
      include 'diagnostic.cmn'
c
      integer istepz,islice,output
      real*8  xkw0
      character*11 file_id
c
      output=0
      call diagno(istepz)
      call status(istepz,islice)
c
c     output of particle and field distribution is done in C++
c
c      if (islice.le.firstout) return
c      call outfield(istepz,islice,xkw0)
c      call outpart(istepz,islice)
c
      return
      end

c
      subroutine outpart(istepz,islice)
c     ==================================================================
c     output of global parameter (t-independend): 
c     z, wiggler field
c     ------------------------------------------------------------------
c
      include  'genesis.def'
      include  'io.cmn'
      include  'particle.cmn'
      include  'input.cmn'
      include  'work.cmn'
      include  'sim.cmn'
c
      integer iz,istepz,islice
c
c     ------------------------------------------------------------------ 
c     output of t independent values with first slice
c
      if ((ippart.le.0).or.(ispart.le.0)) return   !no output at all
      if (mod(istepz,ippart).ne.0) return          !output ippartth step
      if (mod(islice,ispart).ne.0) return          !output ispartth slice
c
      if (istepz.eq.0) call rpos(0,xpart,ypart)
      call getpsi(p1)
c
      if (npart.lt.npart0) then     ! check for particle loss
         do iz=npart+1,npart0       ! indicate lost particles with neg. energy
            gamma(iz)=-1.
         enddo
      endif
c
      write(npar,rec=irecpar) (gamma(iz),iz=1,npart0)
      write(npar,rec=irecpar+1) (p1(iz),iz=1,npart0)
c      write(npar,rec=irecpar+1) (theta(iz),iz=1,npart0)
      write(npar,rec=irecpar+2) (xpart(iz)/xkper0,iz=1,npart0)
      write(npar,rec=irecpar+3) (ypart(iz)/xkper0,iz=1,npart0)
      write(npar,rec=irecpar+4) (px(iz),iz=1,npart0)
      write(npar,rec=irecpar+5) (py(iz),iz=1,npart0)
      irecpar=irecpar+6
      return
      end
c
c
c
      subroutine status(istepz,islice)
c     ==================================================================
c     let user know % complete at every 10%.
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'magnet.cmn'
      include 'io.cmn'
c
      integer istepz,islice
      real*8 xper,yper
c
      if (itdp.ne.0) return
      xper=100.d0*float(istepz)/float(nstepz)
      yper=100.d0*float(istepz-1)/float(nstepz)
      if (mod(xper,10.0d0).lt.mod(yper,10.0d0)) 
     +       write (nlog,20) islice,int(xper)
   20 format ('Slice ', i5,': Simulation ',i3,'% completed.')
c
      return
      end     !status
c
c
c
      subroutine outfield(istepz,islice,xkper0)
c     ==================================================================
c     dump fieldarray  
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'io.cmn'
      include 'field.cmn'
c
      integer i,islice,istepz
      integer ioffset,ih,ifile
      real*8 scltmp,xkper0
c
      if ((ipradi.le.0).or.(isradi.le.0)) return   !no output at all
      if (mod(istepz,ipradi).ne.0) return          !output ipradith step
      if (mod(islice,isradi).ne.0) return          !output isradith slice
c
      scltmp=dxy*eev*xkper0/xks/dsqrt(vacimp)   !
      write(nfld,rec=irecfld) (scltmp* dble(crfield(i)),i=1,ncar*ncar)
      write(nfld,rec=irecfld+1) 
     +        (scltmp*dimag(crfield(i)),i=1,ncar*ncar)
      do ih=2,nhloop
          ioffset=(ih-1)*ncar*ncar
          ifile=nfldh(ih-1)
          write(ifile,rec=irecfld) 
     +	      (scltmp/hloop(ih)* dble(crfield(i)),
     +        i=1+ioffset,ncar*ncar+ioffset)
          write(ifile,rec=irecfld+1) 
     +        (scltmp/hloop(ih)*dimag(crfield(i)),
     +        i=1+ioffset,ncar*ncar+ioffset)
      enddo
c
      irecfld=irecfld+2

      return
      end
c


c
      subroutine closefile(nio)
c     =================================================================
c     closing file
c     ---------------------------------------------------------------
c
      logical isop
c
      if (nio.gt.6) then
        inquire(nio,opened=isop) 
        if (isop) close(nio)                   !close history file
      endif  
      return
      end ! of closefile
c
      function opentextfile(file,status,nio)
c     ==================================================================
c     open ascii file (sequential access)
c     ------------------------------------------------------------------ 
c    
c
      include 'genesis.def'
c
      character*(*) file,status
      integer nio

      opentextfile=nio
      open(nio,file=file,status=status,err=100)
      return
 100  opentextfile=printerr(erropen,file)
      return
      end ! of opentextfile
c
      function openbinfile(root,extension,nio,nsize)
c     ==================================================================
c     open binary file (direct access) as addition output file
c     ------------------------------------------------------------------ 
c    
c
      include 'genesis.def'
c
      character*30 root
      character*4  extension
      character*36 filename
      integer nio,nsize,j,jj

      openbinfile=nio
      j=index(root,' ')
      if (j.eq.0) j=31
      j=j-1
      jj=index(extension,' ')
      if (jj.eq.0) jj=5
      jj=jj-1
      filename=root(1:j)//'.'//extension(1:jj)
      open(nio,file=filename,status='unknown',access='direct',
     +    recl=nsize,err=100)
      return
 100  openbinfile=printerr(erropen,filename)
      return
      end ! of openbinfile
c
c


      subroutine first
c     ============================================
c     initial information for user
c     --------------------------------------------
c
      include 'genesis.def'
      include 'io.cmn'
c 
      write(nlog,100) genver,platf
      return

 100  format('-------------------------------',/,
     c       'Genesis 1.3 has begun execution',/,
     c       '(Version ',f3.1,' ',a,')',/)
      end


      subroutine last()
c     ==================================================================
c     called at end of run.
c     closes all files, which must stay open during the run
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'io.cmn'
      include 'mpi.cmn'
c
      integer ih
c
      write (nlog,100)
      call closefile(nout)   !standard output
      call closefile(nfld)   !field output
      do ih=2,nhmax
         call closefile(nfldh(ih))  !harmonic field output      
         call closefile(ndumph(ih)) !dumped harmonic field     
      enddo
      call closefile(npar)   !particle output 
      call closefile(nfin)   !field input
      call closefile(npin)   !particle input
      call closefile(ndump)  !dumped field
      call closefile(ndmp2)  !dumped particle 
      call closefile(ndis)   !input distribution
      call closetimerec
c      
      write (nlog,200) !genesis has finished
c
      if (nlog.ne.6)  call closefile(nlog)   !log file
c
c      this has to be changed!!!!!!! 
c      pipe out the stop command

c      call MPI_Finalize(mpi_err)
c      stop
c
 100  format('***  closing files')
 200  format(/,'Genesis run has finished',/,
     c         '------------------------') 
      end     !last
c

      function printerr(ierr,text)
c     ========================================================
c     print error messages
c     --------------------------------------------------------
      
      include 'genesis.def'
      include 'io.cmn'

      integer ierr
      character*(*) text

      printerr=ierr
      if (ierr.ge.0) return
      goto (10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
     c      25,26,27,28,29,30,31,32,33)
     c     ,iabs(ierr)
 10   write(nlog,100) text
      return
 11   write(nlog,101) text
      return
 12   write(nlog,102) text
      return
 13   write(nlog,103) text
      return
 14   write(nlog,104) text
      return
 15   write(nlog,105) text
      return
 16   write(nlog,106) text
      return
 17   write(nlog,107) text
      return
 18   write(nlog,108) text
      return
 19   write(nlog,109) text
      return
 20   write(nlog,110) text
      return
 21   write(nlog,111) text
      return
 22   write(nlog,112) text
      return
 23   write(nlog,113) text
      return
 24   write(nlog,114) text
      return
 25   write(nlog,115) text
      return
 26   write(nlog,116) text
      return
 27   write(nlog,117) text
      return
 28   write(nlog,118) text
      return
 29   write(nlog,119) text
      return
 30   write(nlog,120) text
      return
 31   write(nlog,121) text
      return
 32   write(nlog,122) text
      return
 33   write(nlog,123) text
      return
c
c     format statements
c
 100  format('***  File-error: ',a,/,
     c       '***  cannot be opened')
 101  format('***  File-error: ',a,/,
     c       '***  cannot be accessed')
 102  format('***  File-error: ',a,/,
     c       '***  cannot be opened',/,
     c       '***  creating template file: template.in')
 103  format('***  File-error: ',a,/,
     c       '***  error in namelise $newrun')
 104  format('***  Scan-warning: conflict with ITDP',/,
     c       '***  using scan-feature',a)
 105  format('***  Scan-warning: conflict with BEAMFILE',/,
     c       '***  ignoring BEAMFILE: ',a)
 106  format('***  Beamfile-warning: size exceeds NSMAX',/,
     c       '***  ',a)
 107  format('***  Input-error: ',a)
 108  format('***  Input-warning: ',a)
 109  format('***  Input-error: cannot convert to individiual input',/,
     c       '***  ',a)
 110  format('***  Numerical-error: boundary exceeded of',a,/,
     c       '***  ignoring exceeding elements')
 111  format('***  Round-warning: section not multiple of XLAMD',/,
     c       '***  MAGINFILE:',a)    
 112  format('***  Extrapolation-warning: exceeding time window of',/,
     c       '***  BEAMFILE by:',a)
 113  format('***  Scan-error: conflict with MAGINFILE:',a,/,
     c       '***  disabling scan-feature') 
 114  format('***  Scan-error: conflict with MAGOUTFILE:',a,/,
     c       '***  disabling scan-feature')
 115  format('***  Warning: particle loss of ',a,'%')
 116  format('***  Warning: external magnet definition too short for '
     c       ,a)
 117  format('***  Error: invalid filename:',a)
 118  format('***  File-error: cannot read from FIELDFILE:',a)
 119  format('***  Warning: ',a)
 120  format('***  Error: cannot run in background mode.',/,
     c       '***  information needed for ',a)
 121  format('***  Error: CRTIME cannot hold slippage field.',/,
     c       '***  see manual for allocating more memory',a)
 122  format('***  Error: unphysical parameter for loading',/,
     c       '***  ',a)
 123  format('***  ',a)
      end
::::::::::::::
partsim.f
::::::::::::::
      subroutine partsim(tgam,tthet,dgam,dthet,istepz)
c     ==================================================================
c     define the system of ode of the canonic variables
c     t... are the values of the variables at current position
c     d... are the value of the differentioan equation
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
      include 'work.cmn'
c
      complex*16 ctmp
      integer ip,istepz,ih,nharmpart
      real*8 tgam,tthet,dgam,dthet,ztemp1,ztemp2,btper0
      dimension tgam(*),tthet(*)
      dimension dgam(*),dthet(*)
c
c     diff-eq. for longitudinal variables:
c        - energy (gamma)
c        - phase (theta) 
c     ------------------------------------------------------------------
c
c     
      ztemp1=-2.d0*xlamds/xlamd
      ztemp2=xlamd/xlamds
c
      nharmpart=1        !default - only fundamentalacts on electron
      if (iharmsc.ne.0) then   
       nharmpart=nharm   ! self-consistent equation of motion
      endif
c
c      nharmpart=1
c
      do ip=1,npart
c       
        ctmp=dcmplx(0.0)
        do ih =1,nharmpart ! loop over harmonics if self-consitent method is enabled
          ctmp=ctmp+cpart1(ip+(ih-1)*npart)
     +     *dcmplx(dcos(dble(ih)*tthet(ip)),-dsin(dble(ih)*tthet(ip)))
        enddo ! ih
c
        btper0=btper(ip)+ztemp1*dble(ctmp)  !perpendicular velocity
        btpar(ip)=dsqrt(1.d0-btper0/tgam(ip)**2)     !parallel velocity
c
        dthet(ip)=dthet(ip)+ztemp2*(1.-1./btpar(ip))+1.      !dtheta/dz
        dgam (ip)=dgam(ip) +dimag(ctmp)/btpar(ip)/tgam(ip)-ez(ip)  !dgamma/dz
      end do       ! ip
      return
      end     !partsim
c

      subroutine partsorc(istepz)
c     ==================================================================
c     calculates source term for gamma-theta integration 
c     when higher harmonic coupling is considered
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'field.cmn'
      include 'input.cmn'
      include 'magnet.cmn'
      include 'particle.cmn'
      include 'sim.cmn'
      include 'work.cmn'
c
      complex*16 clocal
      integer ip,idx,istepz,ih,ix,nharmpart
      integer idx1,idx2,idx3,idx4,ioffset
      real*8 wei1,wei2,wei3,wei4,rtmp
      real*8  zconst,wei,aw2,xi

c      
c     call space charge routine to calculate the local field Ez
c
c
      nharmpart=1        !default - only fundamentalacts on electron
      if (iharmsc.ne.0) then   
       nharmpart=nharm   ! self-consistent equation of motion
      endif

c
c     check for drifts
c
      if (awz(istepz).lt.tiny) then
         aw2=awdz(istepz)*awdz(istepz)
         do ip=1,npart
           btper(ip)=aw2+px(ip)*px(ip)+py(ip)*py(ip)+1.
         enddo
         do ip=1,npart*nharmpart
           cpart1(ip)=dcmplx(0.0)
         enddo
         return   
      endif
 
c
c      xpart(1)=0
c      ypart(1)=0

      call rpos(istepz,xpart,ypart)                          !position of particles  
c
c     tmp
c
      do ip=1,npart
        aw2=faw2(istepz,xporb(ip),yporb(ip))     !square of wiggler field amplitude
        aw2=aw2+awdz(istepz)*awdz(istepz)             !artificial delay in drifts 
        btper(ip)=aw2+px(ip)*px(ip)+py(ip)*py(ip)+1.       
        rtmp=sqrt(aw2)*xlamds/xlamd               ! effective K-parameter
c
c       interpolation to the grid (index and weight of the 4 surrounding grid points)
c  
        wei1=wx(ip)*wy(ip)
        idx1=ipos(1,ip)
        wei2=wx(ip)*(1.d0-wy(ip))    
        idx2=ipos(2,ip)
        wei3=(1.d0-wx(ip))*wy(ip)
        idx3=ipos(3,ip)
        wei4=(1.d0-wx(ip))*(1.d0-wy(ip))
        idx4=ipos(4,ip)
        do ih=1,nharmpart,2                               !sum over odd harmonics
           ioffset=(ih-1)*ncar*ncar        
           clocal=wei1*crfield(idx1+ioffset)              ! note Genesis field u is related to electric field by
           clocal=clocal+wei2*crfield(idx2+ioffset)       ! u = k*n/ k_u^2 * e/mc^2  E_0
           clocal=clocal+wei3*crfield(idx3+ioffset)
           clocal=clocal+wei4*crfield(idx4+ioffset)
           cpart1(ip+(ih-1)*npart)=conjg(clocal)*rtmp
     +           *besselcoupling(ih)/dble(ih)
        enddo
        do ih=2,nharmpart,2                               !sum over even harmonics
           xi=dble(ih)*xlamd/xlamds/gamma(ip)/gamma(ip)*dsqrt(aw2)      ! nk K/gamma/k_u * x' = coupling -> x' = px/gamma
           ioffset=(ih-1)*ncar*ncar        
           clocal=wei1*crfield(idx1+ioffset)              ! note Genesis field u is related to electric field by
           clocal=clocal+wei2*crfield(idx2+ioffset)       ! u = k*n/ k_u^2 * e/mc^2  E_0
           clocal=clocal+wei3*crfield(idx3+ioffset)
           clocal=clocal+wei4*crfield(idx4+ioffset)
           cpart1(ip+(ih-1)*npart)=conjg(clocal)*rtmp
     +           *besselcoupling(ih)/dble(ih)
     +           *xi*dcmplx(0.,sqrt(2.)*px(ip))          ! missing px here and add I*py for helical undulator 
           
        enddo
      enddo    
C      write(*,*) cpart1(1),rtmp,besselcoupling(1)
c
      return
      end     !partsim     
c

c 
      subroutine harmcoupling(awloc)
c     ============================================================
c     routine to calculate the coupling to higher modes
c     ------------------------------------------------------
c
      include 'genesis.def'
      include 'field.cmn' 
      include 'input.cmn'
c
      real*8 xi,awloc
      integer ih
c
      if (awloc.lt.tiny) then      !drift -> set coupling to zero
        do ih=1,nharm
          besselcoupling(ih)=0.
        enddo
        return
      endif
c
      xi = awloc**2/(1.d0+awloc**2)/2
c
      if (iwityp.ne.0) then         ! helical undulator 
        besselcoupling(1)=1.
        do ih=2,nharm               ! even harmonic is disabled due to the possible
          besselcoupling(ih)=0.     ! break in symmetry
        enddo
      else
         do ih=1,nharm
           if(mod(ih,2).eq.1) then  
            besselcoupling(ih) = (bessj((ih-1)/2,xi*dble(ih))
     +          -bessj((ih+1)/2,xi*dble(ih)))*((-1)**((ih-1)/2))
           else    
            besselcoupling(ih)=0.5*(bessj((ih-2)/2,xi*dble(ih))
     +          -bessj((ih+2)/2,xi*dble(ih)))*(-1)**((ih-2)/2) 
           endif                !note that for full coupling it has to 
                                !mulitplied with the transverse momentum 
         enddo
      endif
      return
      end        ! of harmcoupling
::::::::::::::
pushp.f
::::::::::::::
      subroutine pushp(istepz,xkper0)
c     ==================================================================
c     advance the particles, using runge-kutta (fourth order) method
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
      include 'work.cmn'
c
      integer n,istepz
      real*8  stpz,xkper0
c
      call track(istepz,xkper0)          !advance particle transversly half integragtion step
c
      call esource(istepz,theta)     ! update space charge field
c
      call partsorc(istepz)   !get source term at z0+delz/2
c
c     first step
c     ------------------------------------------------------------------
c
      do n=1,npart    ! clear work arrays
	   k2gg(n)=0.0
	   k2pp(n)=0.0
      end do       ! n
c
c     ode at z0
c
      call partsim(gamma,theta,k2gg,k2pp,istepz)
c
c     second step
c     ------------------------------------------------------------------
c
      stpz=0.5*delz*twopi
      do n=1,npart
c k1 = d/2 k2 + k1
	 gamma(n)=stpz*k2gg(n)+gamma(n)
	 theta(n)=stpz*k2pp(n)+theta(n)
c k3 = k2
	 k3gg(n)=k2gg(n)
	 k3pp(n)=k2pp(n)
c k2 = 0
	 k2gg(n)=0.0
	 k2pp(n)=0.0
      end do       ! n

c ode at z0+delz/2
c
      if (iscrkup.ne.0) then
        call esource(0,theta)     ! update space charge field
      endif     

      call partsim(gamma,theta,k2gg,k2pp,istepz)
c
c     third step
c     ------------------------------------------------------------------
c
      do n=1,npart
c k1 = d/2 k2 + k1
	   gamma(n)=stpz*k2gg(n)+gamma(n)
	   theta(n)=stpz*k2pp(n)+theta(n)
c k1 = -d/2 k3 + k1
	   gamma(n)=-stpz*k3gg(n)+gamma(n)
	   theta(n)=-stpz*k3pp(n)+theta(n)
c k3 = k2/6
	   k3gg(n)=k3gg(n)/6.0
	   k3pp(n)=k3pp(n)/6.0
c k2 = -k2/2
	   k2gg(n)=-k2gg(n)/2.0
	   k2pp(n)=-k2pp(n)/2.0
      end do       ! n
c
c ode at z0+delz/2
c
      if (iscrkup.ne.0) then
        call esource(0,theta)     ! update space charge field
      endif     
c
      call partsim(gamma,theta,k2gg,k2pp,istepz)
c
c     fourth step
c     ------------------------------------------------------------------
c
      stpz=delz*twopi
      do n=1,npart
c k1 = d k2 + k1
	   gamma(n)=stpz*k2gg(n)+gamma(n)
	   theta(n)=stpz*k2pp(n)+theta(n)
c k3 = -k2 + k3
	   k3gg(n)=-k2gg(n)+k3gg(n)
	   k3pp(n)=-k2pp(n)+k3pp(n)
c k2 = -2 k2
	   k2gg(n)=k2gg(n)*2.0
	   k2pp(n)=k2pp(n)*2.0
      end do       ! n
c
c ode at z0+delz
c
      if (iscrkup.ne.0) then
        call esource(0,theta)     ! update space charge field
      endif     
c
      call partsim(gamma,theta,k2gg,k2pp,istepz)
c
      do n=1,npart
	   gamma(n)=gamma(n)+stpz*(k3gg(n)+k2gg(n)/6.0)
	   theta(n)=theta(n)+stpz*(k3pp(n)+k2pp(n)/6.0)
      end do       ! n
c
      call track(istepz,xkper0)        !advance particle transversly half integragtion step
c
c     wakefields or other energy losses if selected
c
      if (dedz.ne.0.) then 
         do n=1,npart
            gamma(n)=gamma(n)+dedz
         enddo
      endif
c 
c     check for particles outside the gridd  
c
      call chk_loss
c
      return
      end     !pushp
c
c
c
      subroutine chk_loss
c     ========================================================================
c     checks for lost particles, reorganizing the particle arrays
c     ------------------------------------------------------------------------ 
c
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
c
      real*8  rtmp
      character*30 closs
      integer delip(npmax),mpart,j,k,i,idel
c
      if (lost.le.0) return            !no loss-initialized in cut-tail
c
      mpart=npart/nbins
      j=0  
c
      do k=0,nbins-2
         do i=1,mpart                         !run over one set of mirror particles
            if (lostid(i+k*mpart).ne.0) then  !lost ?
               j=j+1                          !count &
               delip(j)=i                     !get index
            endif                         
         enddo
         do i=1,j                             !make sure that the found particles
            lostid(delip(i)+(k+1)*mpart)=0    !are not countet in next set
         enddo
      enddo
c
      do i=1,mpart                            !search last set
         if (lostid(i+(nbins-1)*mpart).ne.0) then
            j=j+1
            delip(j)=i
         endif
      enddo
c
      do i=1,j
         do k=0,nbins-1
           gamma(delip(i)+k*mpart)=-1.
         enddo  
      enddo
c      
      idel=0          
      do i=1,npart 
         if (gamma(i).gt.0.) then
            gamma(i-idel)=gamma(i)  
            theta(i-idel)=theta(i)  
            xpart(i-idel)=xpart(i)
            ypart(i-idel)=ypart(i)
            px(i-idel)=px(i)
            py(i-idel)=py(i)
         else    
            idel=idel+1
         endif
         lostid(i)=0   !clear flags of lost particles
      enddo
c
      lost=0
c
c     get numbers right
c
      npart=npart-nbins*j 
      xcuren=xcuren*float(npart)/float(npart+nbins*j)           
      rtmp=1.d0-dble(npart)/dble(npart+nbins*j)
      if (rtmp.gt.0.01) then
         write(closs,100) rtmp*100.
         i=printerr(errpartloss,closs)
      endif   
c
 100  format(f4.0)
      return
      end              !chk_loss
c
c

::::::::::::::
rpos.f
::::::::::::::
      subroutine rpos(istepz,xx,yy)
c     ==================================================================
c     locates the position of the electron on its actual trajectory
c     apply orbit correction to account for wiggle motion.
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'field.cmn'
      include 'input.cmn'
      include 'magnet.cmn'
      include 'particle.cmn'
      include 'sim.cmn'
      
c
      real*8 x,awtmp,wxlow,wylow,xx(*),yy(*)
      integer ip,ix1,iy1,ix2,iy2,istepz
c
      x=(dble(istepz)+0.5)*delz*twopi
c
c     orbit correction ?
c     -------------------------------------------------------------------
      if (iorb.eq.0) then
        do ip=1,npart                   !no orbit correction
	   xporb(ip)=xx(ip)
	   yporb(ip)=yy(ip)
        end do
      else
        if (iwityp.eq.0) then
           do ip=1,npart                                 !planar undulator
              awtmp=dsqrt(faw2(istepz,xx(ip),yy(ip)))   !aw at particle position
	      xporb(ip)=xx(ip)-awtmp*dsin(x)/gamma0
              yporb(ip)=yy(ip) 
           end do 
        else
           do ip=1,npart                                 !helical undulator
              awtmp=dsqrt(faw2(istepz,xx(ip),yy(ip)))   !aw at particle position
	      xporb(ip)=xx(ip)-awtmp*dsin(x)/gamma0
              yporb(ip)=yy(ip)-awtmp*dcos(x)/gamma0 
           end do 
        end if
      end if
c
c     linear interpolation
c     -----------------------------------------------------------
      do ip=1,npart  
         ix1=int((xporb(ip)+dgrid*xkw0)/dxy)+1            !index in cartesian mesh
         iy1=int((yporb(ip)+dgrid*xkw0)/dxy)+1
         if (xporb(ip).lt.-dgrid*xkw0) then
           ix1=1
           ix2=1
           wxlow=0.d0
           lost=lost+1
           lostid(ip)=1
         else 
           if (xporb(ip).ge.dgrid*xkw0) then
             ix1=ncar
             ix2=ncar
             wxlow=1.d0
             lost=lost+1
             lostid(ip)=1
           else
             ix2=ix1+1
             wxlow=xporb(ip)+dgrid*xkw0-dxy*float(ix1-1)
             wxlow=1.d0-wxlow/dxy
           end if
         end if
         if (yporb(ip).lt.-dgrid*xkw0) then
           iy1=1
           iy2=1
           wylow=0.d0
           lost=lost+1 
           lostid(ip)=1
         else 
           if (yporb(ip).ge.dgrid*xkw0) then
             iy1=ncar
             iy2=ncar
             wylow=1.d0
             lost=lost+1
             lostid(ip)=1
           else
             iy2=iy1+1
             wylow=yporb(ip)+dgrid*xkw0-dxy*float(iy1-1)
             wylow=1.d0-wylow/dxy
           end if
         end if
         ipos(1,ip)=(iy1-1)*ncar+ix1 
         ipos(2,ip)=(iy2-1)*ncar+ix1 
         ipos(3,ip)=(iy1-1)*ncar+ix2 
         ipos(4,ip)=(iy2-1)*ncar+ix2 
         wx(ip)=wxlow
         wy(ip)=wylow 
      end do       ! ip
c
      return
      end
c


      subroutine getpsi(psi)
c     ==================================================================
c     calculates the total phase psi as the sum of the radiation phase phi
c     and the particla phase theta.
c     getpsi is only called by outpart to get a non moving bucket.
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'field.cmn'
      include 'input.cmn'
      include 'particle.cmn'
c
      real*8 philoc,wei,psi(npmax)
      integer ip,idx
      complex*16 clocal
c
      do ip=1,npart
        wei=wx(ip)*wy(ip)
        idx=ipos(1,ip)
        clocal=wei*crfield(idx)
        wei=wx(ip)*(1.d0-wy(ip))
        idx=ipos(2,ip)
        clocal=clocal+wei*crfield(idx)
        wei=(1.d0-wx(ip))*wy(ip)
        idx=ipos(3,ip)
        clocal=clocal+wei*crfield(idx)
        wei=(1.d0-wx(ip))*(1.d0-wy(ip))
        idx=ipos(4,ip)
        clocal=clocal+wei*crfield(idx)
        philoc=datan2(dimag(clocal),dble(clocal))
        psi(ip)=philoc+theta(ip) 
      end do   !ip
      return  
      end     !getpsi
::::::::::::::
scan.f
::::::::::::::
      subroutine scaninit
c     ============================================================
c     initialize beam parameter for scanning
c     ------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'sim.cmn'
c
      if (iscan.le.0) return
c
      npart0=npart 
c
      if (iscan.gt.22) return !scan from beamfile      
c
      if (iscan.eq.1 ) sval=gamma0      !save original value
      if (iscan.eq.2 ) sval=delgam
      if (iscan.eq.3 ) sval=curpeak
      if (iscan.eq.4 ) sval=xlamds        !save original value
      if (iscan.eq.5 ) sval=aw0
      if (iscan.eq.6 ) sval=dble(iseed)
      if (iscan.eq.7 ) sval=pxbeam
      if (iscan.eq.8 ) sval=pybeam
      if (iscan.eq.9 ) sval=xbeam
      if (iscan.eq.10) sval=ybeam
      if (iscan.eq.11) sval=rxbeam
      if (iscan.eq.12) sval=rybeam     
      if (iscan.eq.13) sval=xlamd
      if (iscan.eq.14) sval=delaw
      if (iscan.eq.15) sval=alphax      
      if (iscan.eq.16) sval=alphay
      if (iscan.eq.17) sval=emitx
      if (iscan.eq.18) sval=emity
      if (iscan.eq.19) sval=prad0
      if (iscan.eq.20) sval=zrayl
      if (iscan.eq.21) sval=zwaist
      if (iscan.eq.22) sval=awd
c
      return
      end
c
c
      function doscan(islice)
c     =========================================================================
c     modify parameter for scanning - several subroutines have to be rerun
c     -------------------------------------------------------------------------
c
      include 'genesis.def'
      include 'field.cmn'
      include 'input.cmn'
      include 'particle.cmn'
      include 'sim.cmn'
      include 'time.cmn'
c
      real*8 scale
      integer islice,doscan
c
      doscan=0
      if (iscan.le.0) return
      npart=npart0 !compensate former particle losses
c
      if (iscan.gt.22) then    !use data from beamfile for each run of scan
        gamma0=tgam0(islice)  
        delgam=tdgam(islice)
        rxbeam=txrms(islice)
        rybeam=tyrms(islice)
        xbeam=txpos(islice)
        ybeam=typos(islice)
        emitx=temitx(islice)
        emity=temity(islice)
        pxbeam=tpxpos(islice)
        pybeam=tpypos(islice)
        alphax=talphx(islice)
        alphay=talphy(islice)
        xcuren=tcurrent(islice)
        dedz=tloss(islice)*delz*xlamd/eev 
        if (iscan.eq.24) then
           xlamds=0.5*xlamd*(1.d0+aw0*aw0)/gamma0/gamma0
           xks=twopi/xlamds
           call getdiag(delz*xlamd,dxy/xkper0,xks)
        endif
        if (iscan.eq.25) gamma0=gamma0_in
        return 
      endif
c
      scale=1.+svar*(2.*float(islice-1)/float(nslice-1)-1.)
      svalout=sval*scale   !save for output
      if (iscan.eq.6) svalout=sval+islice-1
c
c     beam parameters
c
      if (iscan.eq.1 ) gamma0=sval*scale
      if (iscan.eq.2 ) delgam=sval*scale
      if (iscan.eq.3 ) xcuren=sval*scale
      if (iscan.eq.7 ) pxbeam=sval*scale
      if (iscan.eq.8 ) pybeam=sval*scale
      if (iscan.eq.9 ) xbeam=sval*scale
      if (iscan.eq.10) ybeam=sval*scale
      if (iscan.eq.11) rxbeam=sval*scale
      if (iscan.eq.12) rybeam =sval*scale    
      if (iscan.eq.15) alphax=sval*scale      
      if (iscan.eq.16) alphay=sval*scale
      if (iscan.eq.17) emitx=sval*scale
      if (iscan.eq.18) emity=sval*scale
      if (iscan.le.3) return
      if ((iscan.ge. 7).and.(iscan.le.12)) return
      if ((iscan.ge.15).and.(iscan.le.18)) return
c
c     check for 1-1 simulation
c
      if  (ione4one.ne.0) then
         npart=xcuren*xlamds*zsep/ce
         npart0=npart
      endif
c
c     radiation parameters
c
      if (iscan.eq.4 ) then
          xlamds=sval*scale       
          xks=twopi/xlamds
          call getdiag(delz*xlamd,dxy/xkper0,xks)
      endif    
      if (iscan.eq.19) prad0=sval*scale
      if (iscan.eq.20) zrayl=sval*scale
      if (iscan.eq.21) zwaist=sval*scale
      if (iscan.eq.22) awd=sval*scale
      if ((iscan.eq.4).or.(iscan.ge.19)) return
c
c     magnets parameter
c
      if (iscan.eq.5 ) aw0=sval*scale
      if (iscan.eq.13) xlamd=sval*scale
      if (iscan.eq.14) delaw=sval*scale
      if (iscan.ne.6)  scale=ran1(-nint(sval)) !reinit ran1 function
      call magfield(xkw0,1)                      !recalculate magnetic field
      if (iscan.eq.13) call getdiag(delz*xlamd,dxy/xkper0,xks)
      return
      end
c
::::::::::::::
source.f
::::::::::::::
      subroutine source(istepz, i)
c     ==================================================================
c     construct the source for the wave equation
c     = radiation of the electron beam
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'field.cmn'
      include 'input.cmn'
      include 'magnet.cmn'
      include 'particle.cmn'
      include 'work.cmn'
c
      integer ip,j,idx,istepz,i
      complex*16 ctemp,ctmp
      real*8 stemp,wei,evencoupling,awloc,rtmpy
      character*30 file
c
c
      do j=1,ncar*ncar
	     crsource(j)= (0.d0,0.d0)     !clear 2d array
      end do     ! j
c
      if (awz(istepz).lt.tiny) return        !drift !!!
c
      stemp=0.5d0*vacimp/eev*xcuren/float(npart)*xlamd/xlamds
      stemp=stemp*delz*twopi/dxy/dxy/2.d0  !constant factor 2 because source term is used twice
c
c     debugged - adding harmonic number to the source term
c
      stemp=stemp*dble(i)
c
c
c
      call rpos(istepz,xpart,ypart)      !get particle position on grid
c
      if (mod(i,2).ne.0) then
c
c     calculating the odd harmonics 
c
        do ip=1,npart                  !get undulator field at particle position
         p1(ip)=dsqrt(faw2(istepz,xporb(ip),yporb(ip)))
     c         *stemp/gamma(ip)/btpar(ip)*besselcoupling(i)
         cpart1(ip)=dcmplx(0.0,p1(ip))
        enddo       ! ip
c
      else
c
c     calculate the even harmonics, given by i
c
        evencoupling=dble(i)*xlamd/xlamds
        
	do ip=1,npart
           awloc=dsqrt(faw2(istepz,xporb(ip),yporb(ip)))
           p1(ip)=awloc*stemp/gamma(ip)/btpar(ip)*besselcoupling(i)
           p1(ip)=p1(ip)/gamma(ip)/gamma(ip)*                      ! nk K /gamma0 / k_u *x' -> x' = px/gamma
     +       evencoupling*awloc
           cpart1(ip)=-p1(ip)*dcmplx(sqrt(2.)*px(ip),0)      ! pi/2 phase shift due to coupling with 'i' for planar undulator
        enddo
      endif  
c
c     load source term with local bunching factor  
c

        do ip=1,npart
          ctemp=cpart1(ip)
     +       *dcmplx(dcos(dble(i)*theta(ip)),-dsin(dble(i)*theta(ip)))
          wei=wx(ip)*wy(ip)
          idx=ipos(1,ip)
          crsource(idx)=crsource(idx)+wei*ctemp
          wei=wx(ip)*(1.d0-wy(ip))
          idx=ipos(2,ip)
          crsource(idx)=crsource(idx)+wei*ctemp
          wei=(1.d0-wx(ip))*wy(ip)
          idx=ipos(3,ip)
          crsource(idx)=crsource(idx)+wei*ctemp
          wei=(1.d0-wx(ip))*(1.d0-wy(ip))
          idx=ipos(4,ip)
          crsource(idx)=crsource(idx)+wei*ctemp        
        end do
c

      return
      end     !source
c
::::::::::::::
stepz.f
::::::::::::::
      function stepz(istepz,xkper0)
c     ==================================================================
c     advance one step in z
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'magnet.cmn'
      include 'particle.cmn'
      include 'field.cmn'
c
      integer istepz, i, stepz
      real*8  xkper0
c
      stepz=0
c
      call harmcoupling(awz(istepz))  ! get current coupling to radiation field
c
      call pushp(istepz,xkper0)       !push particles
c
      do i=1, nhloop
        call source(istepz,hloop(i))             !source term for radiation field
        call field(i)
      enddo                      !integrate wave equation
c
c     extensions to genesis 1.3
c 
      call incoherent(awz(istepz))    !subroutine supplied by pascal elleaume
                                      !include incoherent part of 
                                      !synchrotron radiation 
c
c      call diagno(istepz)
c      call status(istepz,islice)
c
c
      return
      end     !stepz

c
::::::::::::::
string.f
::::::::::::::
      function extractnumber(line,val)
c     ======================================================================
c     extract float from line, ignoring preceeding '='-signs
c     ======================================================================
c
      character*(*) line
      character*(255) cline
      real*8 val
      integer extractnumber,i,n,j
c
      extractnumber=0
      n=len(line)   
      i=index(line,'=')+1         !find equal sign
      cline=line(i:n)             !cut string
      call getfirstchar(cline,j)  !check if string is empty
      if (j.eq.0) then            
         extractnumber=-1
         return
      endif
      read(cline,*) val
      return
      end
c
      function extractval(line,values,nval)
c     ======================================================================
c     extract nval data out of line
c     ======================================================================
c
      character*(*) line
      character*(255) cline
      real*8 values(*)
      integer i,j,nval,ix1,ix2,extractval
c
      extractval=0
      cline=line
      do i=1,nval   
         call getfirstchar(cline,ix1) !check for characters
         if (ix1.eq.0) then !empty string
            extractval=-1    
            return
         endif
         ix2=255             !search backwards
         do j=255,ix1+1,-1   !for first space after ix1
           if (cline(j:j).eq.' ') ix2=j  
         enddo
         line=cline(ix1:ix2)    !copy word
         read(line,*) values(i) !get value
         line=cline(ix2:255)    !copy remaining part of the line
         cline=line             !to cline
      enddo
      return
      end
c
      subroutine getfirstchar(line,idx)
c     ======================================================================
c     get the index of the first non space character
c     ======================================================================
c  
      character*(*) line
      integer idx,i 
c
      idx=0
      do i=1,len(line)
         if ((line(i:i).gt.' ').and.(idx.lt.1)) idx=i
      enddo
      return
      end
c
      subroutine touppercase(c)
c     ======================================================================
c     convert string to upper case letters
c     ======================================================================
c
      character*(*) c
      integer i,ic

      do i=1,len(c)
         ic=ichar(c(i:i))
         if ((ic.gt.96).and.(ic.lt.123)) then
            ic=ic-32
            c(i:i)=char(ic)  !replace with uppercase character
         endif 
      enddo   
      return
      end
c
      function strlen(line)
c     ===================================================================
c     check length of given string
c     ===================================================================
c
      integer nchar, nchar1,len,strlen
      character*(*) line

      strlen=1
      nchar1=len(line)
 999  nchar=index(line(nchar1:nchar1),' ')
      if(nchar.ne.0) then
         if(nchar1.gt.1) then
            nchar1=nchar1-1
            goto 999
         endif
      endif
      strlen = nchar1
c
      return
      end
c
c
::::::::::::::
tdepend.f
::::::::::::::
      function dotime(islice)
c     ===================================================================
c     set the beam parameter for the case of time-dependence
c     -------------------------------------------------------------------
c   
      include 'genesis.def'
      include 'input.cmn'
      include 'particle.cmn'
      include 'time.cmn'
      include 'sim.cmn'
c
      integer i,idx,islice,dotime,seed0
      real*8 invcur,zpos,w1,w2
      character*30 cdiff
c
      dotime=0
      if (itdp.eq.0) return
c

      npart=npart0   !compensate former particle losses
c
      if (ndata.le.1) then  !internal generation of time-dependence
         if (curlen.le.0.0) then
            invcur=0.
         else
            invcur=1./curlen
         endif
         zpos=dble(ntail+islice-1)*zsep*xlamds*invcur  !normalized t-position
         xcuren= curpeak*dexp(-0.5d0*zpos*zpos)          !beam current
         if (ione4one.ne.0) then
           npart=xcuren*xlamds*zsep/ce
           npart0=npart
         endif
         call dotimerad(islice)
         return
      endif
c
      zpos=dble((ntail+islice-1)*zsep)*xlamds  !position in m
c
      idx=luf(zpos,tpos,ndata)-1           !find position in array
      if (idx.le.0) idx=1
      if (idx.ge.ndata) idx=ndata-1
c
      if (zpos.lt.tpos(1)) then
        write(cdiff,*) (zpos-tpos(1)) 
        i=printerr(errextra,cdiff)            
      endif
      if (zpos.gt.tpos(ndata)) then
        write(cdiff,*) (zpos-tpos(ndata)) 
        i=printerr(errextra,cdiff)            
      endif
c
      w2=(zpos-tpos(idx))/(tpos(idx+1)-tpos(idx)) !weight of higher index
      w1=1.d0-w2                                  !weight of lower index       
      gamma0=w1*tgam0(idx)+w2*tgam0(idx+1)  !interpolation
      delgam=w1*tdgam(idx)+w2*tdgam(idx+1)  !temporary stored
      rxbeam=w1*txrms(idx)+w2*txrms(idx+1)  !into working arays
      rybeam=w1*tyrms(idx)+w2*tyrms(idx+1)
      xbeam=w1*txpos(idx)+w2*txpos(idx+1)
      ybeam=w1*typos(idx)+w2*typos(idx+1)
      emitx=w1*temitx(idx)+w2*temitx(idx+1)
      emity=w1*temity(idx)+w2*temity(idx+1)
      pxbeam=w1*tpxpos(idx)+w2*tpxpos(idx+1)
      pybeam=w1*tpypos(idx)+w2*tpypos(idx+1)
      alphax=w1*talphx(idx)+w2*talphx(idx+1)
      alphay=w1*talphy(idx)+w2*talphy(idx+1)
      xcuren=w1*tcurrent(idx)+w2*tcurrent(idx+1)  
      dedz=(w1*tloss(idx)+w2*tloss(idx+1))*delz*xlamd/eev 

      if (ione4one.ne.0) then
        npart0=xcuren*xlamds*zsep/ce
        npart=npart0
      endif
      call dotimerad(islice)
      return
            
      end  ! of dotime

      subroutine dotimerad(islice)
c     ===================================================================
c     set the beam parameter for the case of time-dependence
c     -------------------------------------------------------------------
c   

      include 'genesis.def'
      include 'input.cmn'
      include 'field.cmn'
      include 'time.cmn'
      include 'sim.cmn'
c
      integer i,idx,islice
      real*8 invcur,zpos,w1,w2
      character*30 cdiff
      
      if (nraddata.le.1) return
      
         
      zpos=dble((ntail+islice-1)*zsep)*xlamds  !position in m
      idx=luf(zpos,tradpos,nraddata)-1           !find position in array
      if (idx.le.0) then
        write(cdiff,*) (zpos-tradpos(1)) 
        i=printerr(errextra,cdiff)            
        idx=1
      endif
      if (idx.ge.nraddata) then
        write(cdiff,*) (zpos-tradpos(ndata)) 
        i=printerr(errextra,cdiff)            
        idx=nraddata-1
      endif
      w2=(zpos-tradpos(idx))/(tradpos(idx+1)-tradpos(idx)) !weight of higher index
      w1=1.d0-w2                                  !weight of lower index       
      prad0=w1*tprad0(idx)+w2*tprad0(idx+1)  !interpolation
      zrayl=w1*tzrayl(idx)+w2*tzrayl(idx+1)  !temporary stored
      zwaist=w1*tzwaist(idx)+w2*tzwaist(idx+1)  !into working arays
      radphase=w1*tradphase(idx)+w2*tradphase(idx+1)

      if (prad0.lt.0) prad0=0

      return
      end   ! of doradtime
      
::::::::::::::
timerec.f
::::::::::::::
      subroutine opentimerec(n)
c     ==================================================================
c     opens a scratch-file for the time record if necessary
c     ------------------------------------------------------------------
c  
      include 'genesis.def'
      include 'timerec.cmn'
      include 'mpi.cmn'
c      
      integer n
c
      if (mpi_id.gt.0) return   ! only the head node is managing the time-record
c

      if (nofile.ne.0) then     !write crtime to disk?
        ntmp=13
        open(ntmp,status='scratch',access='direct',recl=n*n*16,err=100)
      endif
      return
c
 100  ntmp=printerr(erropen,'CRTIME-scratch')
      call last
      return
      end


      subroutine pushtimerec(cpush,n,irec)
c     ==================================================================
c     copies cpush into crtime array/file
c     ------------------------------------------------------------------

      include 'genesis.def'
      include 'timerec.cmn'
      include 'field.cmn'
      include 'mpi.cmn'

      integer n,it,irec,ioff,ioff2,iloop
      complex*16 cpush(n*n*nhmax)
c
      if (mpi_id.gt.0) return   ! only the head node is managing the time-record
c

      if (nofile.eq.0) then
         ioff=(irec-1)*n*n*nhloop
         do it=1,n*n*nhloop
            crtime(ioff+it)=cpush(it)
         enddo
      else 
         ioff=(irec-1)*nhloop
         do iloop=1,nhloop
           ioff2=ioff*n*n+(iloop-1)*n*n
           write(ntmp,rec=(ioff+iloop),err=10)         
     +             (cpush(it),it=1+ioff2,n*n+ioff2)
         enddo
      endif
      return
 10   it=printerr(errread,'CRTIME-scratch')
      call last
      return
      end  !of pushtimerec
c
c
      subroutine pulltimerec(cpull,n,irec)
c     ==================================================================
c     copies crtime array/file into cpush
c     ------------------------------------------------------------------

      include 'genesis.def'
      include 'timerec.cmn'
      include 'field.cmn'
      include 'mpi.cmn'

      integer n,it,irec,ioff,ioff2,iloop
      complex*16 cpull(n*n*nhmax)
c
      if (mpi_id.gt.0) return   ! only the head node is managing the time-record
c
      if (nofile.eq.0) then
         ioff=(irec-1)*n*n*nhloop 
         do it=1,n*n*nhloop
            cpull(it)=dcmplx(crtime(ioff+it))
         enddo
      else 
         ioff=(irec-1)*nhloop
         do iloop=1,nhloop
            ioff2=ioff*n*n+(iloop-1)*n*n
            read(ntmp,rec=(ioff+iloop),err=10) 
     +            (cpull(it),it=1+ioff2,n*n+ioff2)
         enddo
      endif
      return
 10   it=printerr(errread,'CRTIME-scratch')
      call last
      return

      end  !of pulltimerec


      subroutine closetimerec
c     ====================================================================
c     close the scratch file if necessary
c     --------------------------------------------------------------------
c
      include 'genesis.def'
      include 'timerec.cmn'
      include 'mpi.cmn'
c
      if (mpi_id.gt.0) return   ! only the head node is managing the time-record
c
      if (nofile.ne.0) close(ntmp)
      return
      end
::::::::::::::
track.f
::::::::::::::
      subroutine track(istepz,xkper0)
c     ==================================================================
c     calculates exact soultion for transverse motion
c     this subroutine is call before and after runge-kutta integration
c     of phase and energy
c     ------------------------------------------------------------------
c
      include 'genesis.def'
      include 'input.cmn'
      include 'magnet.cmn'
      include 'particle.cmn'
      include 'work.cmn'
c
      real*8 a1,a2,a3,xtmp,foc,omg,qx,qy,betpar0,xkper0,xoff,yoff
      integer ip,istepz
c
      delz=delz*0.5
c
      betpar0=1.+awz(istepz)**2                ! add weak focusing
      betpar0=dsqrt(1.d0-betpar0/gamma0/gamma0)
      qx= qfld(istepz)+xkx*xkper0**2*awz(istepz)**2/gamma0/betpar0
      qy=-qfld(istepz)+xky*xkper0**2*awz(istepz)**2/gamma0/betpar0
c     
c     calculate magnetic center of quadrupole
c
      xoff=0
      yoff=0
c
csven   the extra factor xkper0 comes from the normalization of x and y      
c
      if (abs(qx).gt.small) then 
       xoff=awdx(istepz)*xkx*xkper0*xkper0*awz(istepz)**2/gamma0/betpar0
       xoff= (xoff+qfld(istepz)*dqfx(istepz)*xkper0)/qx
      endif   
      if (abs(qy).gt.small) then
       yoff=awdy(istepz)*xky*xkper0*xkper0*awz(istepz)**2/gamma0/betpar0      
       yoff=(yoff-qfld(istepz)*dqfy(istepz)*xkper0)/qy
      endif   
      do ip=1,npart
       p1(ip)=xpart(ip)-xoff   ! position relative to magnetic center  
       p2(ip)=ypart(ip)-yoff   ! of quadrupole field
      enddo
c
      if (qx.eq.0.) then
         do ip=1,npart
            xpart(ip)=xpart(ip)+px(ip)*twopi*delz/gamma(ip)/btpar(ip)
         enddo
      else 
         if (qx.gt.0.) then
            do ip=1,npart
               foc=dsqrt(dabs(qx)/gamma(ip)/btpar(ip))
               omg=foc*delz*xlamd
               a1=dcos(omg)
               a2=dsin(omg)/foc
               a3=-a2*foc*foc
               xpart(ip)=a1*p1(ip)+a2*px(ip)/gamma(ip)/btpar(ip)*xkper0
               xpart(ip)=xpart(ip)+xoff
               px(ip)=a3*p1(ip)*gamma(ip)*btpar(ip)/xkper0+a1*px(ip)
            enddo
         else
            do ip=1,npart
               foc=dsqrt(dabs(qx)/gamma(ip)/btpar(ip))
               omg=foc*delz*xlamd
               a1=dcosh(omg)
               a2=dsinh(omg)/foc
               a3=a2*foc*foc
               xpart(ip)=a1*p1(ip)+a2*px(ip)/gamma(ip)/btpar(ip)*xkper0
               xpart(ip)=xpart(ip)+xoff
               px(ip)=a3*p1(ip)*gamma(ip)*btpar(ip)/xkper0+a1*px(ip)
            enddo
         endif
      endif
c
c     field error
c
      if (dabs(awerx(istepz)).gt.tiny) then
         do ip=1,npart
            px(ip)=px(ip)+awerx(istepz)*delz*twopi
csven            xpart(ip)=xpart(ip)+                         !kick at 0.5*delz
csven     +                awerx(istepz)*0.5*delz*twopi/gamma(ip)/btpar(ip) 
         enddo
      endif
c
c     solenoid field
c
      if (dabs(solz(istepz)).gt.tiny) then
         do ip=1,npart
            a1=solz(istepz)*delz*xlamd/gamma(ip) 
            px(ip)=px(ip)+a1*py(ip)
            xpart(ip)=xpart(ip)+0.5*a1/gamma(ip)/btpar(ip) !kick at 0.5*delz
         enddo
      endif
c      
c     and now for the y-plane
c
      if (qy.eq.0.) then
         do ip=1,npart
            ypart(ip)=ypart(ip)+py(ip)*delz*twopi/gamma(ip)/btpar(ip)
         enddo
      else 
         if (qy.gt.0.) then
            do ip=1,npart
               foc=dsqrt(dabs(qy)/gamma(ip)/btpar(ip))
               omg=foc*delz*xlamd
               a1=dcos(omg)
               a2=dsin(omg)/foc
               a3=-a2*foc*foc
               ypart(ip)=a1*p2(ip)+a2*py(ip)/gamma(ip)/btpar(ip)*xkper0
               ypart(ip)=ypart(ip)+yoff
               py(ip)=a3*p2(ip)*gamma(ip)*btpar(ip)/xkper0+a1*py(ip)
            enddo
         else
            do ip=1,npart
               foc=dsqrt(dabs(qy)/gamma(ip)/btpar(ip))
               omg=foc*delz*xlamd
               a1=dcosh(omg)
               a2=dsinh(omg)/foc
               a3=a2*foc*foc
               ypart(ip)=a1*p2(ip)+a2*py(ip)/gamma(ip)/btpar(ip)*xkper0
               ypart(ip)=ypart(ip)+yoff
               py(ip)=a3*p2(ip)*gamma(ip)*btpar(ip)/xkper0+a1*py(ip)
            enddo
         endif
      endif
c
      if (dabs(awery(istepz)).gt.tiny) then
         do ip=1,npart
            py(ip)=py(ip)+awery(istepz)*delz*twopi
csven            ypart(ip)=ypart(ip)
csven     +               +awery(istepz)*0.5*delz*twopi/gamma(ip)/btpar(ip) 
         enddo
      endif
c
c
c     solenoid field
c
      if (dabs(solz(istepz)).gt.tiny) then
         do ip=1,npart
            a1=solz(istepz)*delz*xlamd/gamma(ip) 
            py(ip)=py(ip)-a1*px(ip)
            ypart(ip)=ypart(ip)-0.5*a1/gamma(ip)/btpar(ip) !kick at 0.5*delz
         enddo
      endif
c      
      delz=delz*2.
c      
      return
      end 
